<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>CompilerTest</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/plf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
<ul id='menu'>
   <a href='index.html'><li class='section_name'>VMinus Development</li></a>
   <a href='toc.html'><li>Table of Contents</li></a>
   <a href='coqindex.html'><li>Index</li></a>
   <a href='deps.html'><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">CompilerTest</h1>


<div class="doc">
<a name="lab158"></a><h1 class="section">Testing Vminus: QuickChick in the Large</h1>

</div>
<div class="code code-space">

<br/>
</div>

<div class="doc">
<a name="lab159"></a><h1 class="section">QuickChick and Vellvm</h1>
 One may expect a compiler for a language as simple as IMP to be relatively
    straightforward, and a proof of its correctness to be correspondingly
    so. However, LLVM is a full-featured IR and a faithful formalization is
    necessarily complex and large. When the compiler is under development, even
    stating the correctness of the compiler can be difficult, much less proving
    it.

<div class="paragraph"> </div>

    But if we have interpreters for both the source and target, testing the
    compiler is a much simpler affair. Moreover, the simplicity of the source
    language, i.e. Imp. means that it is really easy to test! 
<div class="paragraph"> </div>

 This lecture shows how QuickChick can be used to test the compiler. For
    simplicity, the target language is the simplified SSA language Vminus, and
    we use a variant of Imp whose names are just memory addresses which can be 
    interpreted in the memory of Vminus states. Imp states and Vminus memory
    are hence essentially the same, and this makes it easy to state correct 
    compilation: after running the source program and its compilation, 
    every Imp variable/address is mapped to the same <span class="inlinecode"><span class="id" type="var">nat</span></span> by both the Imp 
    state and Vminus memory. 

<div class="paragraph"> </div>

    A Vminus state consists of a memory (mapping addresses to <span class="inlinecode"><span class="id" type="var">nat</span></span>), a program 
    counter, an environment mapping locals to nat, a "previous" program 
    counter, and a "previous" environment. The latter two are needed for
    executing phi nodes. A configuration consists of a Vminus state and a CFG,
    which "holds" Vminus instructions organized in basic blocks.
 
<div class="paragraph"> </div>

<a name="lab160"></a><h1 class="section">Testing Whole-Program Compiler Correctness</h1>

<div class="paragraph"> </div>

 Here's a look at what we mean. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode">[<span class="id" type="keyword">Theorem</span></span> <span class="inlinecode"><span class="id" type="var">compile_program_correct_terminating</span>:</span>
  <span class="inlinecode">∀</span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">le</span></span> <span class="inlinecode"><span class="id" type="var">lr</span>,</span>
  <span class="inlinecode">(<span class="id" type="var">g</span>,</span> <span class="inlinecode"><span class="id" type="var">le</span>,</span> <span class="inlinecode"><span class="id" type="var">lr</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">compile</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode">→</span>
  <span class="inlinecode"><span class="id" type="var">imp_terminates</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> <span class="inlinecode">→</span>
  <span class="inlinecode"><span class="id" type="var">vminus_terminates</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span>.]</span>

<div class="paragraph"> </div>

 This is one of the top-level correctness theorems for the compiler: for any 
    initial memory <span class="inlinecode"><span class="id" type="var">m</span></span>, if the source program c terminates with memory (Imp 
    state) <span class="inlinecode"><span class="id" type="var">m'</span></span>, running the compilation result <span class="inlinecode"><span class="id" type="var">g</span></span> (a control flow graph 
    holding the instructions) on the same initial memory <span class="inlinecode"><span class="id" type="var">m</span></span> also results in 
    termination, and with its final (Vminus) memory also being <span class="inlinecode"><span class="id" type="var">m'</span></span>. This is 
    where the coincidence of Imp states and Vminus memory comes into play.

<div class="paragraph"> </div>

    Terminating Imp programs are those that are evaluated to just <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, as the
    following definition shows. 
 
<div class="paragraph"> </div>

 <span class="inlinecode">[<span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">imp_terminates</span></span> <span class="inlinecode">(<span class="id" type="var">c</span>:</span> <span class="inlinecode"><span class="id" type="var">com</span>)</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span>:<span class="id" type="var">mem</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:=</span>
      <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode"><span class="id" type="var">Imp.step</span></span> <span class="inlinecode">(<span class="id" type="var">c</span>,</span> <span class="inlinecode"><span class="id" type="var">m</span>)</span> <span class="inlinecode">(<span class="id" type="var">SKIP</span>,</span> <span class="inlinecode"><span class="id" type="var">m'</span>).]</span>

<div class="paragraph"> </div>

 For Vminus programs on the other hand, running them on an initial memory 
    <span class="inlinecode"><span class="id" type="var">m</span></span> leads to termination with memory <span class="inlinecode"><span class="id" type="var">m'</span></span> if execution reaches a return 
    terminator.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode">[<span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">vminus_terminates</span></span> <span class="inlinecode">(<span class="id" type="var">g</span>:<span class="id" type="var">ListCFG.t</span>)</span> <span class="inlinecode">(<span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span>:<span class="id" type="var">mem</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:=</span>
  <span class="inlinecode">∃</span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>,</span>
    <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>.(<span class="id" type="var">st_pc</span>)</span> <span class="inlinecode">[(<span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">cmd_tmn</span></span> <span class="inlinecode"><span class="id" type="var">tmn_ret</span>)]</span> <span class="inlinecode">∧</span>
    <span class="inlinecode"><span class="id" type="var">st'</span>.(<span class="id" type="var">st_mem</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">m'</span></span> <span class="inlinecode">∧</span>
    <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode">(<span class="id" type="var">init_state</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">m</span>)</span> <span class="inlinecode"><span class="id" type="var">st'</span>.]</span>

<div class="paragraph"> </div>

 The variables <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">st'</span></span> here are determined by "running"/evaluation, as 
    indicated by <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode">(<span class="id" type="var">init_state</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">m</span>)</span> <span class="inlinecode"><span class="id" type="var">st'</span></span>. So checking for their 
    existence is really verifying that an evaluation function reaches <span class="inlinecode"><span class="id" type="var">st'</span></span>
    satisfying the constraints. 

<div class="paragraph"> </div>

 Let us try to write a Checker for the theorem. Looking at the "for all" 
    quantifiers, it would appear that we need generators for Imp commands (<span class="inlinecode"><span class="id" type="var">c</span></span>), 
    Imp states/memories (<span class="inlinecode"><span class="id" type="var">m</span></span>, <span class="inlinecode"><span class="id" type="var">m'</span></span>), control flow graphs (<span class="inlinecode"><span class="id" type="var">g</span></span>) and labels 
    (<span class="inlinecode"><span class="id" type="var">le</span></span>, <span class="inlinecode"><span class="id" type="var">lr</span></span>).

<div class="paragraph"> </div>

    However, note that <span class="inlinecode"><span class="id" type="var">g</span></span>, <span class="inlinecode"><span class="id" type="var">le</span></span>, and <span class="inlinecode"><span class="id" type="var">lr</span></span> are computed by <span class="inlinecode"><span class="id" type="var">compile</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span>, so we 
    don't actually need generators for them. Moreover, we do not want just any 
    <span class="inlinecode"><span class="id" type="var">c</span></span> and <span class="inlinecode"><span class="id" type="var">m'</span></span>, but only terminating Imp programs, and <span class="inlinecode"><span class="id" type="var">m'</span></span> is obtained by 
    running an Imp evaluator on <span class="inlinecode"><span class="id" type="var">m</span></span>. Hence for generation, we only need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A generator for <span class="inlinecode"><span class="id" type="var">mem</span></span>. 

</li>
<li> A generator for Imp programs that are guaranteed to terminate. 

</li>
</ul>
    And for checking, we would need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> An evaluator for Imp that reaches termination, i.e. <span class="inlinecode"><span class="id" type="var">SKIP</span></span>.

</li>
<li> An evaluator for Vminus that reaches termination, i.e. a return 
      terminator. 

</li>
<li> We also need to check that the final state <span class="inlinecode"><span class="id" type="var">st'</span></span> that the Vminus 
      evaluator reaches has the desired memory.

</li>
</ul>

<div class="paragraph"> </div>

 Let us first define an evaluator for Vminus. The evaluator stops when 
    a return terminator is reached. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">vminus_eval</span> (<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">s</span> : <span class="id" type="var">state</span>) (<span class="id" type="var">fuel</span>: <span class="id" type="var">nat</span>) : <span class="id" type="var">err</span> <span class="id" type="var">state</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">fuel</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">inl</span> "out of fuel"<br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">ListCFG.fetch</span> <span class="id" type="var">g</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">s</span>)) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">instr</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_cmd</span> (<span class="id" type="var">snd</span> <span class="id" type="var">instr</span>) (<span class="id" type="var">cmd_tmn</span> <span class="id" type="var">tmn_ret</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">inr</span> <span class="id" type="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">eval_step</span> <span class="id" type="var">g</span> <span class="id" type="var">s</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">s'</span> ⇒ <span class="id" type="var">vminus_eval</span> <span class="id" type="var">g</span> <span class="id" type="var">s'</span> <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">inl</span> <span class="id" type="var">err</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">inl</span> "no instr to fetch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
It is likely that QuickChick will generate large enough Imp programs such 
    that <span class="inlinecode"><span class="id" type="var">vminus_eval</span></span> can run out of fuel. (Think of large <span class="inlinecode"><span class="id" type="var">aexp</span></span> expressions.)
    It is thus useful to have a generator for Imp commands whose <span class="inlinecode"><span class="id" type="var">aexp</span></span> and 
    <span class="inlinecode"><span class="id" type="var">bexp</span></span> expressions are relatively small. As a first step, the following 
    generator limits the size of <span class="inlinecode"><span class="id" type="var">aexp</span></span> expressions to no more than 5 (where 
    size goes by the derived generator for <span class="inlinecode"><span class="id" type="var">aexp</span></span>).
 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Benjamin:&nbsp;Instructions&nbsp;not&nbsp;clear&nbsp;to&nbsp;me&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Nicolas:&nbsp;Noted&nbsp;with&nbsp;Leo's&nbsp;comment&nbsp;on&nbsp;giving&nbsp;the&nbsp;first&nbsp;as&nbsp;example;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;is&nbsp;the&nbsp;revision&nbsp;clearer?&nbsp;*)</span><br/>

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="var">Arbitrary</span> <span class="id" type="keyword">for</span> <span class="id" type="var">aexp</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">round_down_to</span> (<span class="id" type="var">n</span>: <span class="id" type="var">nat</span>) (<span class="id" type="var">k</span>: <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">lt_dec</span> <span class="id" type="var">n</span> <span class="id" type="var">k</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">n</span> <span class="id" type="keyword">else</span> <span class="id" type="var">k</span>.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gen_small_aexp</span>: <span class="id" type="var">GenSized</span> <span class="id" type="var">aexp</span> :=<br/>
&nbsp;&nbsp;{| <span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span> := @<span class="id" type="var">arbitrarySized</span> <span class="id" type="var">aexp</span> <span class="id" type="var">_</span> (<span class="id" type="var">round_down_to</span> 5 <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;|}.<br/>
</div>

<div class="doc">
<a name="lab161"></a><h4 class="section">Exercise: 1 star (GenSmallBexp)</h4>
 Write a similar GenSized instance for <span class="inlinecode"><span class="id" type="var">bexp</span></span> that rounds down its size 
    argument to 5. The generated instances should also have <span class="inlinecode"><span class="id" type="var">aexp</span></span> expressions 
    of size at most 5. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 For <span class="inlinecode"><span class="id" type="var">com</span></span>, recall that the lemma applies only to terminating ones. 
    Hence, let us have two sized generators for <span class="inlinecode"><span class="id" type="var">com</span></span>: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> one that generates only assignment statements and <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, such that the 
      latter are generated with low probability.

</li>
<li> one that generates IF-THEN-ELSE, assignments and <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, but no loops. 

</li>
</ul>
    The first has been done for you.
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">gen_seq_com</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">G</span> <span class="id" type="var">com</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">freq</span> [(4, <span class="id" type="var">liftGen2</span> <span class="id" type="var">CAss</span> <span class="id" type="var">arbitrary</span> <span class="id" type="var">arbitrary</span>); (1, <span class="id" type="var">returnGen</span> <span class="id" type="var">SKIP</span>)]<br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gen</span> := <span class="id" type="var">gen_seq_com</span> <span class="id" type="var">n'</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">liftGen2</span> <span class="id" type="var">CSeq</span> <span class="id" type="var">gen</span> <span class="id" type="var">gen</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab162"></a><h4 class="section">Exercise: 1 star (GenIfCom)</h4>
 Write a generator for Imp <span class="inlinecode"><span class="id" type="var">com</span></span> that generates only If-Then-Else commands, 
    assignments, and <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, but no loops. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 For your convenience, the Shows and Shrinks for <span class="inlinecode"><span class="id" type="var">aexp</span></span>, <span class="inlinecode"><span class="id" type="var">bexp</span></span> and <span class="inlinecode"><span class="id" type="var">com</span></span> 
    have been defined. 
<div class="paragraph"> </div>

 The last thing we need a generator for is <span class="inlinecode"><span class="id" type="var">mem</span></span>. One could generate this by 
    first generating a subset of its domain, i.e. <span class="inlinecode"><span class="id" type="var">Atom.t</span></span>, and then generating 
    the image for this subset; the rest would be kept as some initial value. 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_mem_from_atom_list</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">atom_list</span> : <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) : <span class="id" type="var">G</span> <span class="id" type="var">mem</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">bindGen</span> (<span class="id" type="var">vectorOf</span> (<span class="id" type="var">List.length</span> <span class="id" type="var">atom_list</span>) <span class="id" type="var">arbitrary</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">nat_list</span> ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="var">returnGen</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">index_of_atom_in_list</span> <span class="id" type="var">a</span> <span class="id" type="var">atom_list</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">i</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">List.nth</span> <span class="id" type="var">i</span> <span class="id" type="var">nat_list</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)).<br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">get_fresh_atoms</span> 6 [].<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;get_fresh_atoms&nbsp;6&nbsp;<span class="inlinecode"></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;addr&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gen_domain</span> : <span class="id" type="var">Gen</span> <span class="id" type="var">Atom.t</span> :=<br/>
&nbsp;&nbsp;{| <span class="id" type="var">arbitrary</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">atom_store</span> := <span class="id" type="var">get_fresh_atoms</span> 100 [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oneof</span> (<span class="id" type="var">returnGen</span> (<span class="id" type="var">Atom.fresh</span> [])) (<span class="id" type="var">List.map</span> <span class="id" type="var">returnGen</span> <span class="id" type="var">atom_store</span>)<br/>
&nbsp;&nbsp;|}.<br/>
</div>

<div class="doc">
It would be convenient to show memory too. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">show_memory</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;show_memory<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;mem&nbsp;-&gt;&nbsp;list&nbsp;addr&nbsp;-&gt;&nbsp;string&nbsp;*)</span><br/>
</div>

<div class="doc">
With generation out of the way, we can now return to checking. 
    The Vminus evaluator defined earlier solves a part of the puzzle, namely
    the question of how to check the existence of <span class="inlinecode"><span class="id" type="var">st'</span></span> and <span class="inlinecode"><span class="id" type="var">x</span></span>. However, we 
    also need to check that <span class="inlinecode"><span class="id" type="var">st'</span></span> has the desired memory. Because memories here 
    are total maps, we can only check for equality of memories for a specified 
    domain. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">memory_on_domain_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">addr</span>) (<span class="id" type="var">mem1</span> <span class="id" type="var">mem2</span> : <span class="id" type="var">V.Opsem.mem</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">dom</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a</span> :: <span class="id" type="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">Nat.eqb</span> (<span class="id" type="var">mem1</span> <span class="id" type="var">a</span>) (<span class="id" type="var">mem2</span> <span class="id" type="var">a</span>) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">memory_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">mem1</span> <span class="id" type="var">mem2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("memory_equal: memory at " ++ (<span class="id" type="var">show</span> <span class="id" type="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ " not equal:"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ " mem1 has " ++ (<span class="id" type="var">show</span> (<span class="id" type="var">mem1</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ "; mem2 has " ++ (<span class="id" type="var">show</span> (<span class="id" type="var">mem2</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)%<span class="id" type="var">string</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
This lets us assemble the termination checker for Vminus in full. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">vminus_termination_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">m</span> <span class="id" type="var">m'</span>: <span class="id" type="var">mem</span>) (<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">addr</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">vminus_eval</span> <span class="id" type="var">g</span> (<span class="id" type="var">init_state</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span>) 10000 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">final_state</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "vminus_termination_check: memories not equal"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">memory_on_domain_checker</span> <span class="id" type="var">dom</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">final_state</span>) <span class="id" type="var">m'</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> ("vminus_termination_check: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
And therefore, the <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the lemma in full. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">compile_program_correct_terminating_checker</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_seq_com</span> 5) (<span class="id" type="keyword">fun</span> (<span class="id" type="var">c</span> : <span class="id" type="var">Imp.com</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">dom</span> : <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> (<span class="id" type="var">gen_mem_from_atom_list</span> <span class="id" type="var">dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ []) <span class="comment">(*&nbsp;dummy&nbsp;shrinker&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">show_memory</span> <span class="id" type="var">m</span> <span class="id" type="var">dom</span>) <span class="comment">(*&nbsp;show&nbsp;just&nbsp;for&nbsp;the&nbsp;domain&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">le</span>, <span class="id" type="var">lr</span>) := <span class="id" type="var">compile</span> <span class="id" type="var">c</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">imp_eval</span> <span class="id" type="var">c</span> <span class="id" type="var">m</span> 100 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">s'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">vminus_termination_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span> <span class="id" type="var">s'</span> <span class="id" type="var">dom</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "compile_program_termination: cannot eval imp to Skip"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>))).<br/>
</div>

<div class="doc">
Note the use of <span class="inlinecode"><span class="id" type="var">forAllShrinkShow</span></span> here, which lets us choose the specific 
    Show we want to use; it is needed here because we don't have a <span class="inlinecode"><span class="id" type="keyword">Show</span></span> 
    instance for total maps (which are essentially functions) like <span class="inlinecode"><span class="id" type="var">mem</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab163"></a><h1 class="section">Testing Lemmas for Compiler Correctness</h1>

<div class="paragraph"> </div>

 For the next part, consider the sort of lemmas that would be needed 
    to prove the top-level correctness theorems like the one above. Here's one.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode">[<span class="id" type="keyword">Lemma</span></span> <span class="inlinecode"><span class="id" type="var">comp_aexp_correct</span></span> <span class="inlinecode">:</span> <span class="inlinecode">∀</span> <span class="inlinecode">(<span class="id" type="var">a</span>:<span class="id" type="var">aexp</span>),</span>
    <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> <span class="inlinecode">(<span class="id" type="var">comp_aexp</span></span> <span class="inlinecode"><span class="id" type="var">a</span>)</span> <span class="inlinecode">(<span class="id" type="var">aeval</span></span> <span class="inlinecode"><span class="id" type="var">a</span>).]</span>

<div class="paragraph"> </div>

<span class="inlinecode">[<span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> <span class="inlinecode">(<span class="id" type="var">comp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">FRESH</span></span> <span class="inlinecode">(<span class="id" type="var">val</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>))</span>
           <span class="inlinecode">(<span class="id" type="var">eval</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">mem</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:=</span>
  <span class="inlinecode">∀</span> <span class="inlinecode">(<span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">uid</span>)</span> <span class="inlinecode">(<span class="id" type="var">g</span>:</span> <span class="inlinecode"><span class="id" type="var">ListCFG.t</span>)</span> <span class="inlinecode">(<span class="id" type="var">st</span>:</span> <span class="inlinecode"><span class="id" type="var">V.Opsem.state</span>)</span>
    <span class="inlinecode">(<span class="id" type="var">is</span></span> <span class="inlinecode"><span class="id" type="var">k</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>)</span> <span class="inlinecode">(<span class="id" type="var">v</span>:</span> <span class="inlinecode"><span class="id" type="var">val</span>),</span> 
    <span class="inlinecode">(<span class="id" type="var">cs'</span>,</span> <span class="inlinecode">(<span class="id" type="var">v</span>,</span> <span class="inlinecode"><span class="id" type="var">is</span>))</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">comp</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode">→</span>
    <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)</span> <span class="inlinecode">(<span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span>)</span> <span class="inlinecode">→</span>
    <span class="inlinecode">∃</span> <span class="inlinecode"><span class="id" type="var">st'</span>,</span>
      <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode">∧</span>
      <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">k</span></span> <span class="inlinecode">∧</span>
      <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">∧</span>
      <span class="inlinecode"><span class="id" type="var">ids_preserved</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">∧</span>
      <span class="inlinecode"><span class="id" type="var">good_return</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span> <span class="inlinecode">∧</span>
      <span class="inlinecode"><span class="id" type="var">ctx_incr</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span></span> <span class="inlinecode">∧</span>
      <span class="inlinecode"><span class="id" type="var">eval_val</span></span> <span class="inlinecode">(<span class="id" type="var">st_loc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode">(<span class="id" type="var">eval</span></span> <span class="inlinecode">(<span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)).]</span>

<div class="paragraph"> </div>

 That is, compiling Imp aexp is correct if:

<div class="paragraph"> </div>

<ul class="doclist">
<li> for any compilation run on an initial list of <span class="inlinecode"><span class="id" type="var">uid</span></span>s, 

</li>
<li> wherever we place the compilation result <span class="inlinecode"><span class="id" type="var">is</span></span> in the CFG, as long
      as the program counter is pointed to it
      (<span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span>)</span> <span class="inlinecode">(<span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span>)</span>),

</li>
<li> we can run to the end of compilation (<span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">k</span></span>),

</li>
<li> and in this state <span class="inlinecode"><span class="id" type="var">st'</span></span>, the memory is the same as above; but evaluating 
      the result of the expression in this state (<span class="inlinecode"><span class="id" type="var">eval_val</span></span> <span class="inlinecode">(<span class="id" type="var">st_loc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span>)
      is exactly the same as evaluating it according to the Imp state
      (<span class="inlinecode"><span class="id" type="var">eval</span></span> <span class="inlinecode">(<span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)</span>).

</li>
<li> This last fact may not be obvious from the body of <span class="inlinecode"><span class="id" type="var">comp_correct</span></span>. But 
      note <span class="inlinecode"><span class="id" type="var">comp_aexp_correct</span></span>; the evaluation function passed to it is Imp's 
      <span class="inlinecode"><span class="id" type="var">aeval</span></span>, and this is where the coincidence of Imp states and Vminus 
      memory comes into play.

</li>
</ul>
    There is a bunch of other things that we need here, so as to prove correct
    compilation for com. But the above description is the crux. 
<div class="paragraph"> </div>

 Looking at <span class="inlinecode"><span class="id" type="var">comp_correct</span></span>, it is clear that we need to generate more than 
    just the things we had before. In particular, it would seem that we need 
    generators for the following:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">uid</span></span>

</li>
<li> CFG (<span class="inlinecode"><span class="id" type="var">ListCFG.t</span></span>)

</li>
<li> Vminus states

</li>
<li> Vminus instructions

</li>
<li> values (<span class="inlinecode"><span class="id" type="var">val</span></span>)

</li>
</ul>
    But note again that the only value <span class="inlinecode"><span class="id" type="var">v</span></span> is computed by comp 
    rather than generated, so we don't actually need a generator for <span class="inlinecode"><span class="id" type="var">val</span></span>. 
    Moreover, the CFG <span class="inlinecode"><span class="id" type="var">g</span></span> should not be generated randomly the same way we do 
    others, because it has to satisfy <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span>; it is unlikely for just 
    "any" CFG to satisfy this precondition of the lemma. 
<div class="paragraph"> </div>

<a name="lab164"></a><h4 class="section">Exercise: 1 star (GenUidInsn)</h4>
 Have Generators and Shows for <span class="inlinecode"><span class="id" type="var">uid</span></span> and Vminus <span class="inlinecode"><span class="id" type="var">insn</span></span>, using 
    automation as much as possible. (It is however useful to have custom 
    Shows that are more descriptive.) 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;@Benjamin:&nbsp;All&nbsp;generators&nbsp;and&nbsp;shows&nbsp;required&nbsp;for&nbsp;this&nbsp;have&nbsp;already&nbsp;been<br/>
&nbsp;&nbsp;&nbsp;defined&nbsp;in&nbsp;VminusGen.v,&nbsp;and&nbsp;this&nbsp;is&nbsp;already&nbsp;imported;&nbsp;so&nbsp;the&nbsp;lecture&nbsp;can&nbsp;<br/>
&nbsp;&nbsp;&nbsp;continue&nbsp;uninterrupted&nbsp;with&nbsp;no&nbsp;definitions&nbsp;for&nbsp;these&nbsp;at&nbsp;this&nbsp;point.&nbsp;*)</span><br/>
</div>

<div class="doc">
For Vminus states, we already have a generator for <span class="inlinecode"><span class="id" type="var">mem</span></span>. We have defined a 
    generator and show for <span class="inlinecode"><span class="id" type="var">loc</span></span> for you. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">gen_loc_from_atom_list</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;gen_loc_from_atom_list<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;list&nbsp;uid&nbsp;-&gt;&nbsp;G&nbsp;loc&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">show_locals</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;show_locals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;loc&nbsp;-&gt;&nbsp;list&nbsp;uid&nbsp;-&gt;&nbsp;string&nbsp;*)</span><br/>
</div>

<div class="doc">
We can then define a generator and a show function for Vminus states, 
    given domains for <span class="inlinecode"><span class="id" type="var">mem</span></span> and <span class="inlinecode"><span class="id" type="var">loc</span></span>. For simplicity, we use the same 
    domain for <span class="inlinecode"><span class="id" type="var">ploc</span></span>. 
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_vminus_state</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) : <span class="id" type="var">G</span> <span class="id" type="var">state</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gmem</span> := <span class="id" type="var">gen_mem_from_atom_list</span> <span class="id" type="var">mem_dom</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gloc</span> := <span class="id" type="var">gen_loc_from_atom_list</span> <span class="id" type="var">mem_dom</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">gmem</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">mem</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">pc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">gloc</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">loc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">ppc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">gloc</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">prev_loc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">returnGen</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mkst</span> <span class="id" type="var">mem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">loc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ppc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">prev_loc</span>)))))).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">show_vminus_state</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) : <span class="id" type="var">string</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">show_memory</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="var">mem_dom</span> ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pc: " ++ <span class="id" type="var">show</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">show_locals</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) <span class="id" type="var">loc_dom</span> ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ppc: " ++ <span class="id" type="var">show</span> (<span class="id" type="var">st_ppc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"prev_loc: " ++ <span class="id" type="var">show_locals</span> (<span class="id" type="var">st_ploc</span> <span class="id" type="var">st</span>) <span class="id" type="var">loc_dom</span>)%<span class="id" type="var">string</span>.<br/>
</div>

<div class="doc">
With these out of the way, we can now address the remaining gaps. In its 
    current form, <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> is inefficient and challenging for testing. 
    Firstly, some of the quantities are computed by a function, so it is 
    unnecessary to generate them in the first place, although seemingly 
    suggested by "forall". Secondly, the CFG <span class="inlinecode"><span class="id" type="var">g</span></span> is not just any CFG, but one 
    that satisfies <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> for the compilation result - random generation 
    in the usual way is very, very unlikely to meet this condition, so most
    checks would end up being vacuously true. Thirdly, a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the 
    the existence of <span class="inlinecode"><span class="id" type="var">st'</span></span> really needs to compute it, and this is not part of
    the lemma itself. 

<div class="paragraph"> </div>

    Hence the first order of affairs is to massage the lemma into a 
    <span class="inlinecode"><span class="id" type="var">Checker</span></span>-friendly version.
 
<div class="paragraph"> </div>

 Firstly, let us drop the unnecessary variables, and note the generation 
    of <span class="inlinecode"><span class="id" type="var">state</span></span>.

<div class="paragraph"> </div>

    Definition comp_correct (comp : FRESH (val * list insn))
                            (eval : mem -&gt; nat) : Prop :=
      forall (cs: list uid) (g: ListCFG.t) (k: list insn),
      forall (mem_dom: list Atom.t) (loc_dom: list Atom.t) (st: state),

<div class="paragraph"> </div>

      let (cs', (v, is)) := comp cs in

<div class="paragraph"> </div>

      insns_at_pc g (st_pc st) (is ++ k) -&gt;
      exists st',
        st_mem st' = st_mem st /\
        insns_at_pc g (st_pc st') k /\
        star (Opsem.step g) st st' /\
        ids_preserved cs st st' /\
        good_return cs' v /\
        ctx_incr cs cs' /\
        eval_val (st_loc st') v = Some (eval (st_mem st)).

<div class="paragraph"> </div>

    This is of course not accepted by Coq, but we will eventually get to a
    <span class="inlinecode"><span class="id" type="var">Checker</span></span>.
 
<div class="paragraph"> </div>

 Secondly, we need to write a custom generator that generates CFGs 
    satisfying <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span>. An easier option is to just construct a CFG that 
    loads the instructions at a given pc. 

<div class="paragraph"> </div>

    Let us call this <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg'</span></span> <span class="inlinecode"><span class="id" type="var">pc</span></span> <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>, in correspondence with 
    <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)</span> <span class="inlinecode">(<span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span>)</span>.

<div class="paragraph"> </div>

    However, because <span class="inlinecode"><span class="id" type="var">pc</span></span> may have a positive offset into the block, we should 
    also fill the initial instructions with some dummy instructions (that won't
    be executed). So we make <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg'</span></span> do this. 

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Returns&nbsp;a&nbsp;CFG&nbsp;with&nbsp;a&nbsp;single&nbsp;block&nbsp;containing&nbsp;<span class="inlinecode"><span class="id" type="var">instrs</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">instrs_after</span></span>,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;pc&nbsp;in&nbsp;that&nbsp;block&nbsp;that&nbsp;begins&nbsp;at&nbsp;<span class="inlinecode"><span class="id" type="var">instrs_after</span></span>&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">wrap_code_in_cfg'</span> (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">instrs</span> <span class="id" type="var">instrs_after</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">ListCFG.t</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">empty_cfg</span> := [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span>) := <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">blocks</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ListCFG.update</span> <span class="id" type="var">empty_cfg</span> <span class="id" type="var">lbl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">generate_dummy_insns</span> <span class="id" type="var">offset</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">instrs</span> ++ <span class="id" type="var">instrs_after</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">lbl</span>, <span class="id" type="var">blocks</span>).<br/>
</div>

<div class="doc">
The to-be-Checkable lemma is thus:

<div class="paragraph"> </div>

    <span class="inlinecode">[<span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> <span class="inlinecode">(<span class="id" type="var">comp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">FRESH</span></span> <span class="inlinecode">(<span class="id" type="var">val</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>))</span>
                            <span class="inlinecode">(<span class="id" type="var">eval</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">mem</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:=</span>
      <span class="inlinecode">∀</span> <span class="inlinecode">(<span class="id" type="var">cs</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">uid</span>)</span> <span class="inlinecode">(<span class="id" type="var">k</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>),</span>
      <span class="inlinecode">∀</span> <span class="inlinecode">(<span class="id" type="var">mem_dom</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Atom.t</span>)</span> <span class="inlinecode">(<span class="id" type="var">loc_dom</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Atom.t</span>)</span> <span class="inlinecode">(<span class="id" type="var">st</span>:</span> <span class="inlinecode"><span class="id" type="var">state</span>),</span>

      <span class="inlinecode"><span class="id" type="keyword">let</span></span> <span class="inlinecode">(<span class="id" type="var">cs'</span>,</span> <span class="inlinecode">(<span class="id" type="var">v</span>,</span> <span class="inlinecode"><span class="id" type="var">is</span>))</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" type="var">comp</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span>
      <span class="inlinecode"><span class="id" type="keyword">let</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)</span> <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span>

      <span class="inlinecode">∃</span> <span class="inlinecode"><span class="id" type="var">st'</span>,</span>
        <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">k</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">Opsem.step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">ids_preserved</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">good_return</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">ctx_incr</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">eval_val</span></span> <span class="inlinecode">(<span class="id" type="var">st_loc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode">(<span class="id" type="var">eval</span></span> <span class="inlinecode">(<span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)).]</span>

<div class="paragraph"> </div>

 Thirdly, we know that <span class="inlinecode"><span class="id" type="var">st'</span></span> is given by executing the compilation result; 
    this is the point of "loading" the compilation result at the current <span class="inlinecode"><span class="id" type="var">pc</span></span> 
    in <span class="inlinecode"><span class="id" type="var">g</span></span>, and is of course also stated by <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">Opsem.step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span>. So we 
    need an executable evaluator for Vminus. The state <span class="inlinecode"><span class="id" type="var">st'</span></span> is obtained by 
    running this evaluator until we reach (the start of) <span class="inlinecode"><span class="id" type="var">k</span></span>.

<div class="paragraph"> </div>

    The simplest way of doing so is to stop at the program counter that begins
    <span class="inlinecode"><span class="id" type="var">k</span></span>, and this is actually determined by the CFG that loaded <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span></span>. 

<div class="paragraph"> </div>

    Hence we change <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg</span></span> to return <span class="inlinecode">(<span class="id" type="var">g</span>,</span> <span class="inlinecode"><span class="id" type="var">pc</span>)</span>, where the latter is 
    the <span class="inlinecode"><span class="id" type="var">pc</span></span> that begins <span class="inlinecode"><span class="id" type="var">k</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">instrs</span> <span class="id" type="var">instrs_after</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">ListCFG.t</span> * <span class="id" type="var">pc</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">empty_cfg</span> := [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span>) := <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">blocks</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ListCFG.update</span> <span class="id" type="var">empty_cfg</span> <span class="id" type="var">lbl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">generate_dummy_insns</span> <span class="id" type="var">offset</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">instrs</span> ++ <span class="id" type="var">instrs_after</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;((<span class="id" type="var">lbl</span>, <span class="id" type="var">blocks</span>), (<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span> + <span class="id" type="var">List.length</span> <span class="id" type="var">instrs</span>)).<br/>
</div>

<div class="doc">
Now we need the evaluator itself, which we have defined for you. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">V.Opsem.eval_until_pc</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eval_until_pc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ListCFG.t&nbsp;-&gt;&nbsp;state&nbsp;-&gt;&nbsp;pc&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;err&nbsp;state&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">V.Opsem.eval_step</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eval_step<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ListCFG.t&nbsp;-&gt;&nbsp;state&nbsp;-&gt;&nbsp;err&nbsp;state&nbsp;*)</span><br/>
</div>

<div class="doc">
Now the lemma is:

<div class="paragraph"> </div>

    <span class="inlinecode">[<span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> <span class="inlinecode">(<span class="id" type="var">comp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">FRESH</span></span> <span class="inlinecode">(<span class="id" type="var">val</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>))</span>
                            <span class="inlinecode">(<span class="id" type="var">eval</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">mem</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">nat</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> <span class="inlinecode">:=</span>
      <span class="inlinecode">∀</span> <span class="inlinecode">(<span class="id" type="var">cs</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">uid</span>)</span> <span class="inlinecode">(<span class="id" type="var">k</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>),</span>
      <span class="inlinecode">∀</span> <span class="inlinecode">(<span class="id" type="var">mem_dom</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Atom.t</span>)</span> <span class="inlinecode">(<span class="id" type="var">loc_dom</span>:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">Atom.t</span>)</span> <span class="inlinecode">(<span class="id" type="var">st</span>:</span> <span class="inlinecode"><span class="id" type="var">state</span>),</span>

      <span class="inlinecode"><span class="id" type="keyword">let</span></span> <span class="inlinecode">(<span class="id" type="var">cs'</span>,</span> <span class="inlinecode">(<span class="id" type="var">v</span>,</span> <span class="inlinecode"><span class="id" type="var">is</span>))</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" type="var">comp</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span>
      <span class="inlinecode"><span class="id" type="keyword">let</span></span> <span class="inlinecode">(<span class="id" type="var">g</span>,</span> <span class="inlinecode"><span class="id" type="var">endpoint</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)</span> <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span> <span class="inlinecode"><span class="id" type="keyword">in</span></span>

      <span class="inlinecode"><span class="id" type="keyword">match</span></span> <span class="inlinecode"><span class="id" type="var">V.Opsem.eval_until_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">cutpoint</span></span> <span class="inlinecode">1000</span> <span class="inlinecode"><span class="id" type="keyword">with</span></span>
      <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">inl</span></span> <span class="inlinecode"><span class="id" type="var">err</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">false</span></span> <span class="inlinecode">&nbsp;either&nbsp;out&nbsp;of&nbsp;fuel&nbsp;or&nbsp;no&nbsp;st'&nbsp;*)</span><br/>
</span>      <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" type="var">inr</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">⇒</span> 
        <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">k</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">Opsem.step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">ids_preserved</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">good_return</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span></span> <span class="inlinecode"><span class="id" type="var">v</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">ctx_incr</span></span> <span class="inlinecode"><span class="id" type="var">cs</span></span> <span class="inlinecode"><span class="id" type="var">cs'</span></span> <span class="inlinecode">∧</span>
        <span class="inlinecode"><span class="id" type="var">eval_val</span></span> <span class="inlinecode">(<span class="id" type="var">st_loc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode">(<span class="id" type="var">eval</span></span> <span class="inlinecode">(<span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span>))</span>
      <span class="inlinecode"><span class="id" type="keyword">end</span>.]</span>
 
<div class="paragraph"> </div>

 And with this, the major obstacles are out of the way, and we only have
    to write a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the big conjunction. Because the conjunction is 
    huge, it is easier to write a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for each conjunct. That is, we would
    like to have:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> that checks that two memories are the same. This has already 
      been done.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> that checks for <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> for <span class="inlinecode"><span class="id" type="var">ids_preserved</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> for <span class="inlinecode"><span class="id" type="var">good_return</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> for <span class="inlinecode"><span class="id" type="var">ctxt_incr</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> that checks for equality between the two ways of evaluation.

</li>
</ul>
    Note that <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">Opsem.step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> doesn't need checking, because it is
    implicit in <span class="inlinecode"><span class="id" type="var">eval_until_pc</span></span>. With respect to correctness of <span class="inlinecode"><span class="id" type="var">aexp</span></span> 
    compilation itself, the last is most relevant. 

<div class="paragraph"> </div>

    These are defined below.

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">loc_on_domain_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span> : <span class="id" type="var">loc</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">dom</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a</span> :: <span class="id" type="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">loc1</span> <span class="id" type="var">a</span>, <span class="id" type="var">loc2</span> <span class="id" type="var">a</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n<sub>1</sub></span>, <span class="id" type="var">Some</span> <span class="id" type="var">n<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">Nat.eqb</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> <span class="id" type="keyword">then</span> <span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> "loc_equal: locs disagree" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span>, <span class="id" type="var">None</span> ⇒ <span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">whenFail</span> "loc_equal: locs disagree" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">insns_at_pc_checker</span> `{<span class="id" type="keyword">Show</span> <span class="id" type="var">pc</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">k</span> : <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">k</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">uid</span>, <span class="id" type="var">cmd</span>) :: <span class="id" type="var">instrs</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">ListCFG.fetch</span> <span class="id" type="var">g</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">uid'</span>, <span class="id" type="var">cmd'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_cmd</span> <span class="id" type="var">cmd</span> <span class="id" type="var">cmd'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">insns_at_pc_checker</span> <span class="id" type="var">g</span> (<span class="id" type="var">incr_pc</span> <span class="id" type="var">p</span>) <span class="id" type="var">instrs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("insns_at_pc: cmd at pc "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">show</span> <span class="id" type="var">p</span>) ++ " not equal") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("insns_at_pc: uid at pc "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">show</span> <span class="id" type="var">p</span>) ++ "not equal") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "insns_at_pc: cannot fetch" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">eval_equal_checker</span> (<span class="id" type="var">eval</span>: <span class="id" type="var">mem</span> → <span class="id" type="var">nat</span>) (<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">run_result</span> := <span class="id" type="var">eval_val</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) <span class="id" type="var">v</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">expected_result</span> := <span class="id" type="var">eval</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">run_result</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "eval_equal: evaluation value not the same"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Nat.eqb</span> <span class="id" type="var">n</span> <span class="id" type="var">expected_result</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "eval_equal: run did not obtain any value" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">ids_preserved_checker</span> (<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">st</span> <span class="id" type="var">st'</span>: <span class="id" type="var">state</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">cs</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) (<span class="id" type="var">st_loc</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">good_return_checker</span> (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">val</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">v</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">val_uid</span> <span class="id" type="var">uid</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "good_return: cannot find value" <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">List.existsb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uid'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>) <span class="id" type="var">cs</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">val_nat</span> <span class="id" type="var">n</span> ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">ctx_incr_checker</span> (<span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">cs</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">uid</span> :: <span class="id" type="var">uids</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">List.existsb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uid'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>) <span class="id" type="var">cs'</span>) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr_checker</span> <span class="id" type="var">uids</span> <span class="id" type="var">cs'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("ctx_incr: " ++ <span class="id" type="var">show</span> <span class="id" type="var">uid</span> ++ " not found") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We can now compose the checkers using QuickChick's <span class="inlinecode"><span class="id" type="var">conjoin</span></span> combinator. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">expression_step_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>: <span class="id" type="var">V.Opsem.mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">initial_state</span> <span class="id" type="var">final_state</span>: <span class="id" type="var">V.Opsem.state</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">k</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) (<span class="id" type="var">end_of_expr</span>: <span class="id" type="var">pc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">v</span> : <span class="id" type="var">val</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">conjoin</span> [<span class="id" type="var">ids_preserved_checker</span> <span class="id" type="var">cs</span> <span class="id" type="var">initial_state</span> <span class="id" type="var">final_state</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">end_of_expr</span> <span class="id" type="var">k</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return_checker</span> <span class="id" type="var">cs'</span> <span class="id" type="var">v</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr_checker</span> <span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_equal_checker</span> <span class="id" type="var">eval</span> <span class="id" type="var">final_state</span> <span class="id" type="var">v</span>].<br/>
</div>

<div class="doc">
Finally, a Checker for <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> and <span class="inlinecode"><span class="id" type="var">comp_aexp</span></span> could look like the 
    following. It is convenient to split the <span class="inlinecode"><span class="id" type="var">Checker</span></span> into a part that does 
    only the generation, and a part that does the checking, because a type 
    error can cause the typechecker to get stuck trying to resolve the issue
    by looking for typeclass instances that don't exist.    

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp</span>: <span class="id" type="var">FRESH</span> (<span class="id" type="var">val</span> * <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)) (<span class="id" type="var">eval</span>: <span class="id" type="var">V.Opsem.mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">st</span>: <span class="id" type="var">V.Opsem.state</span>) (<span class="id" type="var">k</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">cs'</span>, (<span class="id" type="var">v</span>, <span class="id" type="var">instrs</span>)) := <span class="id" type="var">comp</span> <span class="id" type="var">cs</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">endpoint</span>) := <span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">V.Opsem.st_pc</span> <span class="id" type="var">st</span>) <span class="id" type="var">instrs</span> <span class="id" type="var">k</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">V.Opsem.eval_until_pc</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="var">endpoint</span> 1000 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">whenFail</span> ("comp_correct_checker: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">st'</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">expression_step_checker</span> <span class="id" type="var">eval</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">k</span> <span class="id" type="var">endpoint</span> <span class="id" type="var">cs</span> <span class="id" type="var">cs'</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_correct_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp</span>: <span class="id" type="var">FRESH</span> (<span class="id" type="var">val</span> * <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)) (<span class="id" type="var">eval</span>: <span class="id" type="var">V.Opsem.mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">extra_insn</span> : <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> (<span class="id" type="var">gen_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ [])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">show_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">start_state</span>: <span class="id" type="var">state</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp</span> <span class="id" type="var">eval</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">cs</span> <span class="id" type="var">start_state</span> <span class="id" type="var">extra_insn</span>))))).<br/>

<br/>
<span class="comment">(**!&nbsp;Section&nbsp;test_compile_aexp&nbsp;extends&nbsp;compiler&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_aexp_correct_checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span>: <span class="id" type="var">aexp</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker</span> (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a</span>) (<span class="id" type="var">aeval</span> <span class="id" type="var">a</span>)).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_aexp_correct_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
Since the compiler has already been proven correct, all tests should 
    succeed. However, they could be succeeding for rather vacuous reasons, and 
    it would be assuring to know that the <span class="inlinecode"><span class="id" type="var">Checker</span></span> indeed fails when the 
    compiler is wrong. 

<div class="paragraph"> </div>

    Exercise: Add mutants to <span class="inlinecode"><span class="id" type="var">comp_aexp</span></span>, and verify that they are causing 
    <span class="inlinecode"><span class="id" type="var">comp_aexp_correct_checker</span></span> to fail. 
 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;END&nbsp;OF&nbsp;LECTURE&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab165"></a><h4 class="section">Exercise: 1 star (compBopCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_bop_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and make sure
    that all tests pass.
 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab166"></a><h4 class="section">Exercise: 1 star (compBexpCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_bexp_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and make sure 
    that all tests pass. 

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Exercise: 3 stars (compStoreCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_store_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and make sure 
    that all tests pass. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab168"></a><h4 class="section">Exercise: 2 stars (compCondCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_cond_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and make sure 
    that all tests pass. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>