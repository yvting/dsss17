<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>CompilerTest: Testing Vminus: QuickChick in the Large</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/plf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
<ul id='menu'>
   <a href='index.html'><li class='section_name'>VMinus Development</li></a>
   <a href='toc.html'><li>Table of Contents</li></a>
   <a href='coqindex.html'><li>Index</li></a>
   <a href='deps.html'><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">CompilerTest<span class="subtitle">Testing Vminus: QuickChick in the Large</span></h1>



<div class="doc">
<a name="lab156"></a><h1 class="section">QuickChick and Vellvm</h1>
 One might expect a compiler (and correctness proof) for a language
    as simple as IMP to be relatively straightforward.

<div class="paragraph"> </div>

    However, LLVM &mdash; even in its simplified Vminus form &mdash; is a
    somewhat complex IR, and a faithful formalization is necessarily
    somewhat involved.  Moreover, when a compiler is under
    development, even <i>stating</i> its correctness can be difficult, much
    less proving it.

<div class="paragraph"> </div>

    Fortunately, <i>testing</i> the compiler and its correctness properties
    is a much simpler affair, as we will see. 
<div class="paragraph"> </div>

 Our target language is the simplified SSA language Vminus defined
    in the other files in this directory, and we use a variant of Imp
    whose names are just memory addresses which can be interpreted in
    the memory of Vminus states. Imp states and Vminus memory are
    hence essentially the same, and this makes it easy to state
    correct compilation: after running the source program and its
    compiled version, every Imp variable/address is mapped to the same
    <span class="inlinecode"><span class="id" type="var">nat</span></span> by both the final Imp state and the final Vminus memory. 
<div class="paragraph"> </div>

 A Vminus state consists of a memory (mapping addresses to <span class="inlinecode"><span class="id" type="var">nat</span></span>),
    a program counter, an environment (mapping "locals" to <span class="inlinecode"><span class="id" type="var">nat</span></span>), a
    "previous" program counter, and a "previous" environment; the
    latter two are used for executing phi nodes. A configuration
    consists of a Vminus state and a CFG, which holds Vminus
    instructions organized in basic blocks. 
<div class="paragraph"> </div>

<a name="lab157"></a><h1 class="section">Vminus Review</h1>

<div class="paragraph"> </div>

 To make this case study chapter self contained, we begin with a
    very brief review of the relevant parts of the Vminus intermediate
    language and compiler.  If you're already familiar with
    Vminus (e.g., from reading the other files and working exercises),
    you can safely skip to the next section.

<div class="paragraph"> </div>

    A Vminus program in concrete syntax vs abstract syntax looks like
    this (warning: program is meant to only show syntax, and is not
    meant to make sense):

<div class="paragraph"> </div>

<pre>
block #1:
 %1 = add 0 0 
  (* binary operations can work on numeric literals, i.e. [nat] *) 
 %2 = add %1 5 (* also, on variables *) 
 %3 = sub %2 %1 
 %4 = store @1 %3 
  (* store the value held by %3 into memory at address @1 *)
</pre>

<div class="paragraph"> </div>

    Looking ahead a bit:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The Imp store and Vminus memory are the same;

</li>
<li> Vminus addresses and Imp variables are the same (modulo the
      <span class="inlinecode"><span class="id" type="var">AId</span></span> constructor).

</li>
</ul>
    Hence Imp programs have direct access to Vminus memory, and
    assignment statements correspond directly to such a store
    instruction.

<div class="paragraph"> </div>

    Also note that %4 is redundant here; the reason is to make the
    abstract syntax uniform

<div class="paragraph"> </div>

<pre>
 %5 = store @1 1 (* We can store literals too *) 
 %6 = load @1 
 %7 = cbr %6 #2 #3 
  (* conditional branch based on value held in %6, again with %7 being 
     redundant; we can also branch on [nat] *)

block #2:
 %8 = load @1 
 %9 = jmp #4 (* unconditional jump *)

block #3:
 %10 = load @1 
 %11 = jmp #4

block #4:
 %12 = phi [(#2, %8) ; (#3, %10)] 
  (* %12 takes the value held by %8 if control came from block #2, 
     or the value held by %10 if control came from #3 *) 
 %13 = jmp #5

block #5:
 %14 = ret (* again, variable %14 is unnecessary *)
</pre>

<div class="paragraph"> </div>

In the abstract syntax, every instruction is defined as:

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">insn</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">(<span class="id" type="var">uid</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">cmd</span>)%<span class="id" type="var">type</span>.</span>

<div class="paragraph"> </div>

In the above, the <span class="inlinecode"><span class="id" type="var">uid</span></span> is the number on the left of the equal sign,
and <span class="inlinecode"><span class="id" type="var">cmd</span></span> is defined as follows:

<div class="paragraph"> </div>

<pre>
Inductive cmd : Set :=
| cmd_bop : bop -&gt; val -&gt; val -&gt; cmd cmd_phi : list phiarg -&gt; cmd
| cmd_tmn : tmn -&gt; cmd cmd_load : addr -&gt; cmd cmd_store : addr -&gt;
| val -&gt; cmd.
</pre>

<div class="paragraph"> </div>

Each individual command is either a binary operation like add, a
phi-node that joins a list of blocks, a terminator, a load, or a
store; all of these are illustrated in the program above.

<div class="paragraph"> </div>

Moreover, a program is represented as a control flow graph (see
<a href="ListCFG.html"><span class="inlineref">ListCFG</span></a> for implementation and \CHAP{CFG] for the interface). 
A CFG is just a list of blocks, with one of
them distinguished (via <span class="inlinecode"><span class="id" type="var">lbl</span></span>) as the entry block.

<div class="paragraph"> </div>

<pre>
Definition t := (lbl * list block)%type. 
Local Notation cfg := t.
</pre>

<div class="paragraph"> </div>

A program counter is a block label <span class="inlinecode"><span class="id" type="var">lbl</span></span> with an offset n within the
block.

<div class="paragraph"> </div>

<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">pc</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">(<span class="id" type="var">lbl</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">nat</span>)%<span class="id" type="var">type</span>.</span> <span class="inlinecode"></span>

<div class="paragraph"> </div>

A block has its label <span class="inlinecode"><span class="id" type="var">lbl</span></span> and contains a list of instructions.

<div class="paragraph"> </div>

<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">block</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">(<span class="id" type="var">lbl</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">insn</span>)%<span class="id" type="var">type</span>.</span> <span class="inlinecode"></span>

<div class="paragraph"> </div>

As the concrete syntax shows, there are 3 forms of identifiers, and
they are all implemented as Atoms with the fresh interface.

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">uid</span></span>: The % prefix, e.g. %7.

</li>
<li> <span class="inlinecode"><span class="id" type="var">addr</span></span>: The @ prefix, e.g @1.

</li>
<li> <span class="inlinecode"><span class="id" type="var">lbl</span></span>: The  prefix, e.g. 3.  A potential point of confusion would

</li>
</ul>
be that <span class="inlinecode"><span class="id" type="keyword">Check</span></span>, <span class="inlinecode"><span class="id" type="keyword">Print</span></span>, etc. shows <span class="inlinecode"><span class="id" type="var">addr</span></span> instead of <span class="inlinecode"><span class="id" type="var">lbl</span></span> or <span class="inlinecode"><span class="id" type="var">uid</span></span>, because
<span class="inlinecode"><span class="id" type="var">addr</span></span> is last-defined.

<div class="paragraph"> </div>

<a name="lab158"></a><h1 class="section">Overview of the Compiler</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

One key part of compilation to Vminus, as an SSA form, is the need to generate
fresh labels as we go along. Hence the compiler is implemented as a Writer 
monad, specifically as a CMD (and EXP) following the definitions below:

<div class="paragraph"> </div>

In <span class="inlinecode"><span class="id" type="var">Classes.v</span></span>: 

<div class="paragraph"> </div>

<span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="keyword">Definition</span></span> <span class="inlinecode"><span class="id" type="var">ST</span></span> <span class="inlinecode">(<span class="id" type="var">M</span>:<span class="id" type="keyword">Type</span>)</span> <span class="inlinecode">(<span class="id" type="var">A</span>:<span class="id" type="keyword">Type</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" type="var">M</span></span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" type="var">M</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">A</span>).</span> 

<div class="paragraph"> </div>

In <span class="inlinecode"><span class="id" type="var">Compiler.v</span></span>:
<pre>
Notation EXP := (ST (list uid)).
Definition cstate := (list lbl * list uid * list block)%type.
Notation CMD := (ST cstate).
</pre>

<div class="paragraph"> </div>

The <span class="inlinecode"><span class="id" type="var">CMD</span></span> monad is the compiler monad at the top level, handling in particular 
control flow (that is why the block labels are threaded through). The <span class="inlinecode"><span class="id" type="var">EXP</span></span>
monad is for compilation within basic blocks. A subtlety: the compiler compiles 
every Imp assignment statement to its own basic block, so basic blocks in the 
compilation result are not maximal in the usual sense. 

<div class="paragraph"> </div>

For both, <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">uid</span></span> is the set of uids already generated thus far; similar
interpretation for <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">lbl</span></span>. The <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">block</span></span> part holds the compilation 
result thus far (recall that each block contains its own block label). 

<div class="paragraph"> </div>

Compilation is hence activated by running the function <span class="inlinecode"><span class="id" type="var">CMD</span></span> on appropriate
initial (empty) lists:

<div class="paragraph"> </div>

<pre>
Definition compile (c:com) : ListCFG.t * lbl * lbl :=
  let '(_, _, bs, (le, lr)) := comp_prog c ([], [], []) in
    ((le, bs), le, lr).

Definition comp_prog (c:com) : CMD (lbl * lbl) :=
  do r &lt;- fresh_lbl;
  do x &lt;- liftF fresh;
  do _ &lt;- add_insns r [(x, cmd_tmn tmn_ret)];
  do e &lt;- comp_com c r;
  ret (e, r).
</pre>

<div class="paragraph"> </div>

Looking at just <span class="inlinecode"><span class="id" type="var">compile</span></span> and the signature of <span class="inlinecode"><span class="id" type="var">comp_prog</span></span>, the compiler 
instantiates the value part of the state monad <span class="inlinecode"><span class="id" type="var">A</span></span> in <span class="inlinecode"><span class="id" type="var">S</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">A</span></span> as <span class="inlinecode"><span class="id" type="var">lbl</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" type="var">lbl</span></span>.
The first component is the entry (block) label that can be used to start 
executing the compilation result; the second component is the label for the 
block that control goes to -after- executing the compilation result. 

<div class="paragraph"> </div>

Note: <span class="inlinecode"><span class="id" type="var">le</span></span> and <span class="inlinecode"><span class="id" type="var">lr</span></span> are used consistently to mean as such. 

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

This is why the CFG (i.e. compiled program) returned has its entry label as 
<span class="inlinecode"><span class="id" type="var">le</span></span>, and the compilation result is just <span class="inlinecode"><span class="id" type="var">bs</span></span>. 

<div class="paragraph"> </div>

For <span class="inlinecode"><span class="id" type="var">comp_prog</span></span> itself: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">fresh_label</span></span> creates a new block with no instructions in the compilation 
  result, gives it a fresh label, and returns this as its value <span class="inlinecode"><span class="id" type="var">r</span></span>

</li>
<li> it generates a fresh <span class="inlinecode"><span class="id" type="var">uid</span></span> (%&lt;number&gt;) via <span class="inlinecode"><span class="id" type="tactic">fresh</span></span>, and returns this <span class="inlinecode"><span class="id" type="var">x</span></span>

</li>
<li> it sets, in the compilation result, the block labeled <span class="inlinecode"><span class="id" type="var">r</span></span> to hold a 
  return terminator instruction. To see this concretely, look at 
  <span class="inlinecode"><span class="id" type="var">block</span></span> <span class="inlinecode">#5:</span> <span class="inlinecode">%14</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">ret</span></span> above.

</li>
<li> it compiles the program <span class="inlinecode"><span class="id" type="var">c</span></span> via <span class="inlinecode"><span class="id" type="var">comp_com</span></span>. Note that the desired 
  return-of-control <span class="inlinecode"><span class="id" type="var">lbl</span></span> <span class="inlinecode"><span class="id" type="var">r</span></span> is passed to it. The <span class="inlinecode"><span class="id" type="var">lbl</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> returned by <span class="inlinecode"><span class="id" type="var">comp_com</span></span> 
  is in turn the entry-of-control label <span class="inlinecode"><span class="id" type="var">e</span></span>.

</li>
</ul>
As the documentation for <span class="inlinecode"><span class="id" type="var">comp_com</span></span> states:
  The input <span class="inlinecode"><span class="id" type="var">lr</span></span> is the "continuation" label of the block to which control
  should return after the command is done.  The output is the label of the
  entry block for the command. 

<div class="paragraph"> </div>

  Note how compiling a sequence <span class="inlinecode">[<span class="id" type="var">c<sub>1</sub></span>;;<span class="id" type="var">c<sub>2</sub></span>]</span> threads the control through the 
  commands in reverse order.

<div class="paragraph"> </div>

<a name="lab159"></a><h1 class="section">Overview of Relevant Files</h1>

<div class="paragraph"> </div>

<ul class="doclist">
<li> <a href="Vminus.html"><span class="inlineref">Vminus</span></a> defines the syntax of Vminus.

</li>
<li> <a href="VminusOpSem.html"><span class="inlineref">VminusOpSem</span></a> defines its semantics.   

<div class="paragraph"> </div>

     <span class="inlinecode"><span class="id" type="keyword">Inductive</span></span> <span class="inlinecode"><span class="id" type="var">step</span></span> <span class="inlinecode">(<span class="id" type="var">g</span>:<span class="id" type="var">Cfg.t</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">state</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">state</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> summarizes everything. 
     A Vminus state is described below, but concretely for now:

</li>
</ul>

<div class="paragraph"> </div>

<pre>
     Record state := mkst { st_mem  : mem
                          ; st_pc   : pc
                          ; st_loc  : loc
                          ; st_ppc  : pc     (* predecessor pc *)
                          ; st_ploc : loc    (* predecessor "locals" *) 
                          }.
</pre>

<div class="paragraph"> </div>

<ul class="doclist">
<li> <a href="Compiler.html"><span class="inlineref">Compiler</span></a> shows the compiler. 

</li>
<li> <a href="CFG.html"><span class="inlineref">CFG</span></a> is the interface for CFGs; <a href="ListCFG.html"><span class="inlineref">ListCFG</span></a> is the implementation.

</li>
<li> <a href="CompilerProp.html"><span class="inlineref">CompilerProp</span></a> holds the relevant content for what follows, and is 
     described in-line.

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab160"></a><h1 class="section">Testing Whole-Program Compiler Correctness</h1>

<div class="paragraph"> </div>

 Here's a property we'd like to test (from <a href="CompilerProp.html"><span class="inlineref">CompilerProp</span></a>):

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span>&nbsp;<span class="id" type="var">compile_program_correct_terminating</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;<span class="id" type="var">c</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">le</span>&nbsp;<span class="id" type="var">lr</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>,&nbsp;<span class="id" type="var">le</span>,&nbsp;<span class="id" type="var">lr</span>)&nbsp;=&nbsp;<span class="id" type="var">compile</span>&nbsp;<span class="id" type="var">c</span>&nbsp;→<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">imp_terminates</span>&nbsp;<span class="id" type="var">c</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>&nbsp;→<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">vminus_terminates</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 This is one of the top-level correctness theorems for the
    compiler: for any initial memory <span class="inlinecode"><span class="id" type="var">m</span></span>, if the source program <span class="inlinecode"><span class="id" type="var">c</span></span>
    terminates with memory (Imp state) <span class="inlinecode"><span class="id" type="var">m'</span></span>, running the compilation
    result <span class="inlinecode"><span class="id" type="var">g</span></span> (a control flow graph holding the instructions) on the
    same initial memory <span class="inlinecode"><span class="id" type="var">m</span></span> also results in termination, and with its
    final (Vminus) memory also being <span class="inlinecode"><span class="id" type="var">m'</span></span>. 
<div class="paragraph"> </div>

 (This is where the coincidence of Imp states and Vminus
    memory comes into play.) 
<div class="paragraph"> </div>

 Recall: An Imp program takes memory <span class="inlinecode"><span class="id" type="var">m</span></span> to memory <span class="inlinecode"><span class="id" type="var">m'</span></span>, written
    <span class="inlinecode"><span class="id" type="var">imp_terminates</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> if, when started in <span class="inlinecode"><span class="id" type="var">m</span></span>, it multi-steps to
    just <span class="inlinecode"><span class="id" type="var">SKIP</span></span>, with new memory <span class="inlinecode"><span class="id" type="var">m'</span></span>. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">imp_terminates</span>&nbsp;(<span class="id" type="var">c</span>:&nbsp;<span class="id" type="var">com</span>)&nbsp;(<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>:&nbsp;<span class="id" type="var">mem</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">star</span>&nbsp;<span class="id" type="var">Imp.step</span>&nbsp;(<span class="id" type="var">c</span>,&nbsp;<span class="id" type="var">m</span>)&nbsp;(<span class="id" type="var">SKIP</span>,&nbsp;<span class="id" type="var">m'</span>).
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 For Vminus programs <span class="inlinecode"><span class="id" type="var">g</span></span>, on the other hand, running on an initial
    memory <span class="inlinecode"><span class="id" type="var">m</span></span> leads to with memory <span class="inlinecode"><span class="id" type="var">m'</span></span>, written <span class="inlinecode"><span class="id" type="var">vminus_terminates</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span>
    <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">m'</span></span> if execution starting from <span class="inlinecode"><span class="id" type="var">m</span></span> reaches a return terminator
    <span class="inlinecode"><span class="id" type="var">tmn_ret</span></span>. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">vminus_terminates</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>:&nbsp;<span class="id" type="var">ListCFG.t</span>)&nbsp;(<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>:&nbsp;<span class="id" type="var">mem</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∃&nbsp;<span class="id" type="var">x</span>&nbsp;<span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">st'</span>.(<span class="id" type="var">st_pc</span>)&nbsp;[(<span class="id" type="var">x</span>,&nbsp;<span class="id" type="var">cmd_tmn</span>&nbsp;<span class="id" type="var">tmn_ret</span>)]&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">st'</span>.(<span class="id" type="var">st_mem</span>)&nbsp;=&nbsp;<span class="id" type="var">m'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">star</span>&nbsp;(<span class="id" type="var">step</span>&nbsp;<span class="id" type="var">g</span>)&nbsp;(<span class="id" type="var">init_state</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">m</span>)&nbsp;<span class="id" type="var">st'</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 The variables <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">st'</span></span> here are determined by the evaluation
    relation, as indicated by <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode">(<span class="id" type="var">init_state</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode"><span class="id" type="var">m</span>)</span> <span class="inlinecode"><span class="id" type="var">st'</span></span>. So
    checking for their existence can be thought of as verifying that
    an evaluation function yields some <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">st'</span></span> satisfying the
    constraints. 
<div class="paragraph"> </div>

 Let us try to write a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the property

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Theorem</span>&nbsp;<span class="id" type="var">compile_program_correct_terminating</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;<span class="id" type="var">c</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">le</span>&nbsp;<span class="id" type="var">lr</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>,&nbsp;<span class="id" type="var">le</span>,&nbsp;<span class="id" type="var">lr</span>)&nbsp;=&nbsp;<span class="id" type="var">compile</span>&nbsp;<span class="id" type="var">c</span>&nbsp;→<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">imp_terminates</span>&nbsp;<span class="id" type="var">c</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>&nbsp;→<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">vminus_terminates</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">m</span>&nbsp;<span class="id" type="var">m'</span>.
<div class="paragraph"> </div>

</div>
    Looking naively at these "for all" quantifiers, it would appear that 
    we need generators for Imp commands (<span class="inlinecode"><span class="id" type="var">c</span></span>), Imp states / Vminus
    memories (<span class="inlinecode"><span class="id" type="var">m</span></span>, <span class="inlinecode"><span class="id" type="var">m'</span></span>), control flow graphs (<span class="inlinecode"><span class="id" type="var">g</span></span>) and labels (<span class="inlinecode"><span class="id" type="var">le</span></span>,
    <span class="inlinecode"><span class="id" type="var">lr</span></span>). 
<div class="paragraph"> </div>

 However, <span class="inlinecode"><span class="id" type="var">g</span></span>, <span class="inlinecode"><span class="id" type="var">le</span></span>, and <span class="inlinecode"><span class="id" type="var">lr</span></span> are computed by <span class="inlinecode"><span class="id" type="var">compile</span></span> <span class="inlinecode"><span class="id" type="var">c</span></span>, so we
    don't actually need generators for them. Moreover, we do not want
    just any <span class="inlinecode"><span class="id" type="var">m'</span></span>; rather, <span class="inlinecode"><span class="id" type="var">m'</span></span> should be obtained by running an Imp
    evaluator (which we have) on <span class="inlinecode"><span class="id" type="var">m</span></span>. Hence for generation, we only
    need
    (1) a generator for <span class="inlinecode"><span class="id" type="var">mem</span></span> and
    (2) a generator for Imp programs. 
<div class="paragraph"> </div>

 And for checking that the property holds, we need
    (1) an evaluator for Vminus that repeatedly steps until it reaches a
        return terminator and
    (2) a way to check that the final state <span class="inlinecode"><span class="id" type="var">st'</span></span> from the Vminus
        evaluator has the desired memory contents. 
<div class="paragraph"> </div>

 One small technical issue with all of this is that memories are
    total maps on an infinite domain, so we cannot actually check that
    two memories are equal.

<div class="paragraph"> </div>

    Fortunately, for compiler testing, we only care about variables
    that appear in the source program. So as a simplification, we fix
    a domain of variables from which we draw when generating Imp
    programs, and we use the same set when checking memories. 
<div class="paragraph"> </div>

 The domain is fixed up front in <a href="ImpGen.html"><span class="inlineref">ImpGen</span></a> like this: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">id_store</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;id_store&nbsp;=&nbsp;get_fresh_atoms&nbsp;5&nbsp;<span class="inlinecode"></span><br/>
&nbsp;*)</span><br/>
</div>

<div class="doc">
The generator <span class="inlinecode"><span class="id" type="var">gen_id</span></span> generates fresh identifiers (atoms) by sampling from 
    this fixed domain. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">gen_id</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;gen_id&nbsp;=&nbsp;gen_fresh&nbsp;id_store<br/>
&nbsp;*)</span><br/>
</div>

<div class="doc">
Given the generator for <span class="inlinecode"><span class="id" type="var">id</span></span>s, we can generate <span class="inlinecode"><span class="id" type="var">aexp</span></span>, <span class="inlinecode"><span class="id" type="var">bexp</span></span>, and
    <span class="inlinecode"><span class="id" type="var">com</span></span> as follows. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gen_aexp</span> : <span class="id" type="var">GenSized</span> <span class="id" type="var">aexp</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">arbitrarySized</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">base_gen</span> := <span class="id" type="var">oneOf</span> [(<span class="id" type="var">n</span> &lt;- <span class="id" type="var">arbitrary</span> ;; <span class="id" type="var">ret</span> (<span class="id" type="var">ANum</span> <span class="id" type="var">n</span>)) ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">id</span> &lt;- <span class="id" type="var">gen_id</span> ;; <span class="id" type="var">ret</span> (<span class="id" type="var">AId</span> <span class="id" type="var">id</span>))] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">fix</span> <span class="id" type="var">gen_aexp_func</span> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">base_gen</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">binop_gen</span> <span class="id" type="var">op</span> := <span class="id" type="var">liftGen2</span> <span class="id" type="var">op</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">gen_aexp_func</span> <span class="id" type="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">gen_aexp_func</span> <span class="id" type="var">n'</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oneOf</span> [<span class="id" type="var">binop_gen</span> <span class="id" type="var">APlus</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">binop_gen</span> <span class="id" type="var">AMinus</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">binop_gen</span> <span class="id" type="var">AMult</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">base_gen</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="var">Arbitrary</span> <span class="id" type="keyword">for</span> <span class="id" type="var">bexp</span>.<br/>
<span class="id" type="var">Derive</span> <span class="id" type="var">Arbitrary</span> <span class="id" type="keyword">for</span> <span class="id" type="var">com</span>.<br/>
</div>

<div class="doc">
For convenience, <span class="inlinecode"><span class="id" type="keyword">Show</span></span> instances for <span class="inlinecode"><span class="id" type="var">aexp</span></span>, <span class="inlinecode"><span class="id" type="var">bexp</span></span>, and <span class="inlinecode"><span class="id" type="var">com</span></span>
    have already been defined (in <a href="ImpGen.html"><span class="inlineref">ImpGen</span></a>). These give more
    compact output than the ones that would automatically be
    derived. 
<div class="paragraph"> </div>

 We also need a generator for <span class="inlinecode"><span class="id" type="var">mem</span></span>.  Given the (global) list
    <span class="inlinecode"><span class="id" type="var">id_store</span></span> of "interesting variables", we generate a list of
    numeric values of the same length and use it to build a function
    from atoms to values; other variables are set to 0. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_mem</span> : <span class="id" type="var">G</span> <span class="id" type="var">mem</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">nat_list</span> &lt;- <span class="id" type="var">vectorOf</span> (<span class="id" type="var">List.length</span> <span class="id" type="var">id_store</span>) <span class="id" type="var">arbitrary</span> ;; <br/>
&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">index_of_atom_in_list</span> <span class="id" type="var">a</span> <span class="id" type="var">id_store</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">i</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">List.nth</span> <span class="id" type="var">i</span> <span class="id" type="var">nat_list</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">show_memory</span> (<span class="id" type="var">mem</span>: <span class="id" type="var">mem</span>) : <span class="id" type="var">string</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">show_memory_on_domain</span> <span class="id" type="var">mem</span> <span class="id" type="var">id_store</span>.<br/>
</div>

<div class="doc">
Next let's define an evaluator for Vminus that stops when a return
    terminator is reached (or when it gets stuck or runs out of
    fuel &mdash; we'll return different results in these cases so that we can
    tell what happened later). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">vminus_eval_result</span> :=<br/>
| <span class="id" type="var">Terminates</span> (<span class="id" type="var">st</span>: <span class="id" type="var">state</span>): <span class="id" type="var">vminus_eval_result</span><br/>
| <span class="id" type="var">GoesWrong</span> (<span class="id" type="var">s</span>: <span class="id" type="var">string</span>): <span class="id" type="var">vminus_eval_result</span><br/>
| <span class="id" type="var">Timeout</span> : <span class="id" type="var">vminus_eval_result</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">vminus_eval</span> (<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">st</span> : <span class="id" type="var">state</span>) (<span class="id" type="var">fuel</span>: <span class="id" type="var">nat</span>) :<br/>
&nbsp;&nbsp;<span class="id" type="var">vminus_eval_result</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">fuel</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">Timeout</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">ListCFG.fetch</span> <span class="id" type="var">g</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">st</span>)) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">instr</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_cmd</span> (<span class="id" type="var">snd</span> <span class="id" type="var">instr</span>) (<span class="id" type="var">cmd_tmn</span> <span class="id" type="var">tmn_ret</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">Terminates</span> <span class="id" type="var">st</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval_step</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">st'</span> ⇒ <span class="id" type="var">vminus_eval</span> <span class="id" type="var">g</span> <span class="id" type="var">st'</span> <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">GoesWrong</span> <span class="id" type="var">err</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">GoesWrong</span> "no instr to fetch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
With generation out of the way, we can now return to checking.
    First, a checker for equality of memories on "interesting
    variables": 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">memory_equal_checker_on_domain</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">addr</span>) (<span class="id" type="var">mem1</span> <span class="id" type="var">mem2</span> : <span class="id" type="var">mem</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">dom</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a</span> :: <span class="id" type="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">Nat.eqb</span> (<span class="id" type="var">mem1</span> <span class="id" type="var">a</span>) (<span class="id" type="var">mem2</span> <span class="id" type="var">a</span>) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">memory_equal_checker_on_domain</span> <span class="id" type="var">l</span> <span class="id" type="var">mem1</span> <span class="id" type="var">mem2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("memory_equal: memory at " ++ (<span class="id" type="var">show</span> <span class="id" type="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ " not equal:" ++ " mem1 has " ++ (<span class="id" type="var">show_nat</span> (<span class="id" type="var">mem1</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ "; mem2 has " ++ (<span class="id" type="var">show_nat</span> (<span class="id" type="var">mem2</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)%<span class="id" type="var">string</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">memory_equal_checker</span> := <span class="id" type="var">memory_equal_checker_on_domain</span> <span class="id" type="var">id_store</span>.<br/>
</div>

<div class="doc">
Note that we define this operation to return a <span class="inlinecode"><span class="id" type="var">Checker</span></span> rather
    than a <span class="inlinecode"><span class="id" type="var">bool</span></span>, so that, if we find that the two memories are <i>not</i>
    equal, we can stash away a useful error message. 
<div class="paragraph"> </div>

 Now we can assemble the equal-final-state checker for Vminus. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Axiom</span> <span class="id" type="var">vminus_fuel</span> : <span class="id" type="var">nat</span>.<br/>
<span class="id" type="var">Extract</span> <span class="id" type="var">Constant</span> <span class="id" type="var">vminus_fuel</span> ⇒ "1000".<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">vminus_final_state_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">m</span> <span class="id" type="var">m'</span>: <span class="id" type="var">mem</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">vminus_eval</span> <span class="id" type="var">g</span> (<span class="id" type="var">init_state</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span>) <span class="id" type="var">vminus_fuel</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Terminates</span> <span class="id" type="var">final_state</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "vminus_final_state_checker: memories not equal"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">memory_equal_checker</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">final_state</span>) <span class="id" type="var">m'</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">GoesWrong</span> <span class="id" type="var">err</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> ("vminus_final_state_checker: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Timeout</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> <span class="id" type="var">tt</span>  <span class="comment">(*&nbsp;discard&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
And now, the <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the whole correctness property. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">compile_program_correct_terminating_checker'</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrink</span> <span class="id" type="var">arbitrary</span> <span class="id" type="var">shrink</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">c</span> : <span class="id" type="var">Imp.com</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> <span class="id" type="var">gen_mem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ []) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">show_memory</span> <span class="id" type="var">m</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">le</span>, <span class="id" type="var">lr</span>) := <span class="id" type="var">compile</span> <span class="id" type="var">c</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">imp_eval</span> <span class="id" type="var">c</span> <span class="id" type="var">m</span> 100 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">s'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("cfg is: " ++ <span class="id" type="var">show</span> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">vminus_final_state_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span> <span class="id" type="var">s'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">tt</span> <span class="comment">(*&nbsp;discard&nbsp;the&nbsp;test&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)).<br/>
</div>

<div class="doc">
There are a few things to note here. 
<div class="paragraph"> </div>

 Firstly, note the use of <span class="inlinecode"><span class="id" type="var">forAllShrinkShow</span></span> here, which lets us
    choose the specific <span class="inlinecode"><span class="id" type="keyword">Show</span></span> we want to use; it is needed here
    because we don't have a <span class="inlinecode"><span class="id" type="keyword">Show</span></span> instance for total maps (which are
    essentially functions) like <span class="inlinecode"><span class="id" type="var">mem</span></span>. 
<div class="paragraph"> </div>

 Secondly, note the use of <span class="inlinecode"><span class="id" type="var">checker</span></span> <span class="inlinecode"><span class="id" type="var">tt</span></span>: This counts the test case
    as a discard, for which we can see the count later. We could have
    used <span class="inlinecode"><span class="id" type="var">checker</span></span> <span class="inlinecode"><span class="id" type="var">true</span></span> to treat the test as a "pass," but then we
    might be falsely reassured if most tests succeed because they just
    hold vacuously. 
<div class="paragraph"> </div>

 And now, let's check it! 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*!&nbsp;Extract&nbsp;Constant&nbsp;Test.defNumTests&nbsp;=&gt;&nbsp;"20".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checker'.&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+++&nbsp;Passed&nbsp;20&nbsp;tests&nbsp;(7&nbsp;discards)<br/>
*)</span><br/>
</div>

<div class="doc">
One thing to note is that we are generating non-terminating Imp
    programs about 1/3 of the time, but the ones that are not
    discarded all pass.

<div class="paragraph"> </div>

    If we start getting too many discards, one way to find out why is
    to change <span class="inlinecode"><span class="id" type="var">checker</span></span> <span class="inlinecode"><span class="id" type="var">tt</span></span> above to fail, so that we can examine the
    counterexamples.

<div class="paragraph"> </div>

    But for now we can live with the discard rate. 
<div class="paragraph"> </div>

 However, we also notice something else that's more problematic: Running
    20 tests takes 15 seconds!

<div class="paragraph"> </div>

    On reflection, this is not too surprising, as the grammar contains
    a number of binary nodes and the <span class="inlinecode"><span class="id" type="var">size</span></span> parameter is treated as a
    bound on <i>depth</i>, not total number of nodes.  So our generated
    tests are <i>huge</i>.  

<div class="paragraph"> </div>

    Let's see how huge... 
<div class="paragraph"> </div>

 We quickly whack together some functions for calculating
    the sizes of Imp code. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">size_aexp</span> (<span class="id" type="var">a</span> : <span class="id" type="var">aexp</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">a</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ANum</span> <span class="id" type="var">_</span> ⇒ 1<br/>
&nbsp;&nbsp;| <span class="id" type="var">AId</span> <span class="id" type="var">_</span> ⇒ 1<br/>
&nbsp;&nbsp;| <span class="id" type="var">APlus</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">AMinus</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">AMult</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span> ⇒ <span class="id" type="var">size_aexp</span> <span class="id" type="var">a<sub>1</sub></span> + <span class="id" type="var">size_aexp</span> <span class="id" type="var">a<sub>2</sub></span> + 1<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">size_bexp</span> (<span class="id" type="var">b</span> : <span class="id" type="var">bexp</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">BTrue</span> | <span class="id" type="var">BFalse</span> ⇒ 1<br/>
&nbsp;&nbsp;| <span class="id" type="var">BEq</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span><br/>
&nbsp;&nbsp;| <span class="id" type="var">BLe</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">a<sub>2</sub></span> ⇒ <span class="id" type="var">size_aexp</span> <span class="id" type="var">a<sub>1</sub></span> + <span class="id" type="var">size_aexp</span> <span class="id" type="var">a<sub>2</sub></span> + 1<br/>
&nbsp;&nbsp;| <span class="id" type="var">BAnd</span> <span class="id" type="var">b<sub>1</sub></span> <span class="id" type="var">b<sub>2</sub></span> ⇒ <span class="id" type="var">size_bexp</span> <span class="id" type="var">b<sub>1</sub></span> + <span class="id" type="var">size_bexp</span> <span class="id" type="var">b<sub>2</sub></span> + 1<br/>
&nbsp;&nbsp;| <span class="id" type="var">BNot</span> <span class="id" type="var">b</span> ⇒ <span class="id" type="var">size_bexp</span> <span class="id" type="var">b</span> + 1<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">size_com</span> (<span class="id" type="var">c</span> : <span class="id" type="var">com</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">SKIP</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1<br/>
&nbsp;&nbsp;| (<span class="id" type="var">x</span> ::= <span class="id" type="var">a</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 + <span class="id" type="var">size_aexp</span> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">c<sub>1</sub></span> ;; <span class="id" type="var">c<sub>2</sub></span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">size_com</span> <span class="id" type="var">c<sub>1</sub></span> + <span class="id" type="var">size_com</span> <span class="id" type="var">c<sub>2</sub></span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">IFB</span> <span class="id" type="var">b</span> <span class="id" type="var">THEN</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">ELSE</span> <span class="id" type="var">c<sub>2</sub></span> <span class="id" type="var">FI</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">size_bexp</span> <span class="id" type="var">b</span> + <span class="id" type="var">size_com</span> <span class="id" type="var">c<sub>1</sub></span> + <span class="id" type="var">size_com</span> <span class="id" type="var">c<sub>2</sub></span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">WHILE</span> <span class="id" type="var">b</span> <span class="id" type="var">DO</span> <span class="id" type="var">c</span> <span class="id" type="var">END</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">size_bexp</span> <span class="id" type="var">b</span> + <span class="id" type="var">size_com</span> <span class="id" type="var">c</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Now add a <span class="inlinecode"><span class="id" type="var">collect</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">compile_program_correct_terminating_checker_collect</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrink</span> <span class="id" type="var">arbitrary</span> <span class="id" type="var">shrink</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">c</span> : <span class="id" type="var">Imp.com</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">collect</span> (<span class="id" type="var">size_com</span> <span class="id" type="var">c</span>) (<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> <span class="id" type="var">gen_mem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ []) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">show_memory</span> <span class="id" type="var">m</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">le</span>, <span class="id" type="var">lr</span>) := <span class="id" type="var">compile</span> <span class="id" type="var">c</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">imp_eval</span> <span class="id" type="var">c</span> <span class="id" type="var">m</span> 100 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">s'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("cfg is: " ++ <span class="id" type="var">show</span> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">vminus_final_state_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span> <span class="id" type="var">s'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">tt</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>))).<br/>
</div>

<div class="doc">
Now test: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*!&nbsp;Extract&nbsp;Constant&nbsp;Test.defNumTests&nbsp;=&gt;&nbsp;"20".<br/>
&nbsp;&nbsp;&nbsp;&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checker_collect.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;:&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;90<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;8<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;578<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;34<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;322<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;307<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;2264<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;208<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;2<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;171<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;115<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;11<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;:&nbsp;10<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+++&nbsp;Passed&nbsp;20&nbsp;tests&nbsp;(6&nbsp;discards)<br/>
*)</span><br/>
</div>

<div class="doc">
Yep, some of these look too big 
<div class="paragraph"> </div>

 To fix this, we can use the <span class="inlinecode"><span class="id" type="var">resize</span></span> combinator to change the
    maximum size that will be passed to sized generators to something
    other than the default (which is 10). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">resize</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;nat&nbsp;-&gt;&nbsp;G&nbsp;?A&nbsp;-&gt;&nbsp;G&nbsp;?A<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?A&nbsp;:&nbsp;<span class="inlinecode"></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" type="keyword">Type</span></span>&nbsp;<br/>
*)</span><br/>
</div>

<div class="doc">
Let's set it to 3. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">compile_program_correct_terminating_checker</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrink</span> (<span class="id" type="var">resize</span> 3 <span class="id" type="var">arbitrary</span>) <span class="id" type="var">shrink</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">c</span> : <span class="id" type="var">Imp.com</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> <span class="id" type="var">gen_mem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ []) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">show_memory</span> <span class="id" type="var">m</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">le</span>, <span class="id" type="var">lr</span>) := <span class="id" type="var">compile</span> <span class="id" type="var">c</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">imp_eval</span> <span class="id" type="var">c</span> <span class="id" type="var">m</span> 100 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">s'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("cfg is: " ++ <span class="id" type="var">show</span> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">vminus_final_state_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span> <span class="id" type="var">s'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">tt</span> <span class="comment">(*&nbsp;discard&nbsp;the&nbsp;test&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)).<br/>
</div>

<div class="doc">
Now we can run 10000 tests in a few seconds: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*!&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checkers.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+++&nbsp;Passed&nbsp;10000&nbsp;tests&nbsp;(2841&nbsp;discards)<br/>
*)</span><br/>
</div>

<div class="doc">
EX2 (GenComWithSmallExpr)  Add a <span class="inlinecode"><span class="id" type="var">collect</span></span> to the checker that collects the exact Imp command
    for each test.  Set <span class="inlinecode"><span class="id" type="var">defNumTests</span></span> to 20 to avoid looking at too
    many examples, and use QuickChick to take a look.  Notice that the
    generated programs tend to be quite short but that they tend to
    involve quite large arithmetic and/or boolean expressions.  This
    distribution may not be giving us the most effective testing.

<div class="paragraph"> </div>

    Write a generator for <span class="inlinecode"><span class="id" type="var">com</span></span> that takes a size bound <span class="inlinecode"><span class="id" type="var">n</span></span> and
    generates commands in which <span class="inlinecode"><span class="id" type="var">bexp</span></span> and <span class="inlinecode"><span class="id" type="var">aexp</span></span> expressions have
    size at most <span class="inlinecode"><span class="id" type="var">n</span></span>. 
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 EX<sub>1</sub> (IdentifyDiscards)  By design of the Checker, we expect discards to be due to non-terminating 
    programs. To investigate this, change the Checker so that "out of fuel" 
    is treated as a failure. Is the counterexample what you expect? Can you 
    be absolutely sure that such counterexamples are due to "out of fuel" 
    rather than because of a genuine bug? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab161"></a><h1 class="section">Mutation Testing</h1>

<div class="paragraph"> </div>

 Beyond discarded tests, we are also interested in the tests that
    <i>pass</i>.  In particular, we want to make sure that they are passing
    because the property really holds, rather than some oversight in
    generation or formulation of the Checker. To do that, we can
    <i>mutate</i> the compiler to falsify the property and check that the
    Checker fails in this case.

<div class="paragraph"> </div>

    <i>Mutation testing</i> is a powerful technique for increasing
    confidence in the quality of our tests.  QuickChick comes with a
    command-line tool for mutation testing, but it isn't quite able
    yet to handle the Vminus development.  So for the moment we'll
    just play with mutants manually. 
<div class="paragraph"> </div>

 We've left a suggested mutant in a comment in the <span class="inlinecode"><span class="id" type="var">APlus</span></span> case of the
    <span class="inlinecode"><span class="id" type="var">comp_aexp</span></span> function in <a href="Compiler.html"><span class="inlineref">Compiler</span></a>.

<div class="paragraph"> </div>

    Inserting this mutant gives us the following. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*!&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
===&gt; 
<pre>
    QuickChecking compile_program_correct_terminating_checker
    Id 4 := (ANum 60 + ANum 25)
    mem: [(addr 5, 77) (addr 4, 73) (addr 3, 34) 
          (addr 2, 21) (addr 1, 59) ]
    cfg is: (entry 2, blks: lbl 1: []
    vminus_final_state_checker: memories not equal
    memory_equal: memory at Id 4 not equal: mem1 has 35; mem2 has 85
    *** Failed after 67 tests and 31 shrinks. (40 discards)
</pre>

<div class="paragraph"> </div>

<a name="lab162"></a><h4 class="section">Exercise: 2 stars (comp_aexp_minus_mutant)</h4>
 Do the same for the suggested mutant for the <span class="inlinecode"><span class="id" type="var">AMinus</span></span> case in <span class="inlinecode"><span class="id" type="var">comp_aexp</span></span>.
    Repeat the experiment for a few times. Are the results what you expect? 
    Investigate why. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*!&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checker.&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

 This finishes the testing of the top-level compiler correctness
    property.

<div class="paragraph"> </div>

    Compare the relative ease of developing this testing
    infrastructure with what's involved in proving the theorem!

<div class="paragraph"> </div>

    The key part of that proof involves defining a <span class="inlinecode"><span class="id" type="var">match_states</span></span>
    relation very carefully, and it can take many iterations to get it
    right, both in terms of correctness and sufficiency for the proof
    to go through.  This is on top of making sure that the compiler
    has no bugs.

<div class="paragraph"> </div>

    Testing can help us to quickly pin down bugs in the compiler
    itself, so that we can focus on the proof.  In contrast to the
    proof development, our generators have all been automatically
    derived, and writing the Checker for this is considerably
    simpler. 
<div class="paragraph"> </div>

<a name="lab163"></a><h1 class="section">Testing Lemmas for Compiler Correctness</h1>

<div class="paragraph"> </div>

 Next, let's look at a property for which the infrastructure needed
    for testing is a bit more elaborate: one of the lemmas that is
    used in proving the top-level correctness theorem... 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Lemma</span>&nbsp;<span class="id" type="var">comp_aexp_correct</span>&nbsp;:&nbsp;∀&nbsp;(<span class="id" type="var">a</span>:<span class="id" type="var">aexp</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct</span>&nbsp;(<span class="id" type="var">comp_aexp</span>&nbsp;<span class="id" type="var">a</span>)&nbsp;(<span class="id" type="var">aeval</span>&nbsp;<span class="id" type="var">a</span>).
<div class="paragraph"> </div>

</div>
where <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> is Vminus's generic "expression compilation correctness" 
property (used for both arithmetic and boolean expressions)... 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">comp_correct</span>&nbsp;(<span class="id" type="var">comp</span>&nbsp;:&nbsp;<span class="id" type="var">FRESH</span>&nbsp;(<span class="id" type="var">val</span>&nbsp;*&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>&nbsp;:&nbsp;<span class="id" type="var">mem</span>&nbsp;→&nbsp;<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;(<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">cs'</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">uid</span>)&nbsp;(<span class="id" type="var">g</span>:&nbsp;<span class="id" type="var">ListCFG.t</span>)&nbsp;(<span class="id" type="var">st</span>:&nbsp;<span class="id" type="var">V.Opsem.state</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">is</span>&nbsp;<span class="id" type="var">k</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>)&nbsp;(<span class="id" type="var">v</span>:&nbsp;<span class="id" type="var">val</span>),&nbsp;<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs'</span>,&nbsp;(<span class="id" type="var">v</span>,&nbsp;<span class="id" type="var">is</span>))&nbsp;=&nbsp;<span class="id" type="var">comp</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;→<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st</span>)&nbsp;(<span class="id" type="var">is</span>&nbsp;++&nbsp;<span class="id" type="var">k</span>)&nbsp;→<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∃&nbsp;<span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;interesting&nbsp;part:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;=&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">k</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">star</span>&nbsp;(<span class="id" type="var">step</span>&nbsp;<span class="id" type="var">g</span>)&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_val</span>&nbsp;(<span class="id" type="var">st_loc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">v</span>&nbsp;=&nbsp;<span class="id" type="var">Some</span>&nbsp;(<span class="id" type="var">eval</span>&nbsp;(<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>))&nbsp;∧<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;details:&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ids_preserved</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return</span>&nbsp;<span class="id" type="var">cs'</span>&nbsp;<span class="id" type="var">v</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">cs'</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 That is, compiling Imp <span class="inlinecode"><span class="id" type="var">aexp</span></span> is correct if:

<div class="paragraph"> </div>

<ul class="doclist">
<li> for <i>any compilation</i> of some expression run on an initial
          list of <span class="inlinecode"><span class="id" type="var">uid</span></span>s,

</li>
<li> wherever we place the compilation <i>result</i> <span class="inlinecode"><span class="id" type="var">is</span></span> in the
          <i>CFG</i>, with the program counter pointing to it (<span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span>
          <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span>)</span> <span class="inlinecode">(<span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span>)</span>),

</li>
<li> <i>we can run to the end</i> of the compiled code and reach a
          state <span class="inlinecode"><span class="id" type="var">st'</span></span> (<span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">k</span></span>), and

</li>
<li> in this state <span class="inlinecode"><span class="id" type="var">st'</span></span>, the <i>memory is the same</i> as
          above (<span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">st_mem</span></span> <span class="inlinecode"><span class="id" type="var">st</span></span>), and

</li>
<li> <i>evaluating the result</i> of the expression in this
          state (<span class="inlinecode"><span class="id" type="var">eval_val</span></span> <span class="inlinecode">(<span class="id" type="var">st_loc</span></span> <span class="inlinecode"><span class="id" type="var">st'</span>)</span> <span class="inlinecode"><span class="id" type="var">v</span></span>) is <i>exactly the same</i> as
          evaluating it according to the Imp state (<span class="inlinecode"><span class="id" type="var">eval</span></span> <span class="inlinecode">(<span class="id" type="var">st_mem</span></span>
          <span class="inlinecode"><span class="id" type="var">st</span>)</span>).

</li>
</ul>

<div class="paragraph"> </div>

    This last fact may not be obvious from the body of
    <span class="inlinecode"><span class="id" type="var">comp_correct</span></span>. But note <span class="inlinecode"><span class="id" type="var">comp_aexp_correct</span></span>, which passes Imp's
    <span class="inlinecode"><span class="id" type="var">aeval</span></span> as the evaluation function.  (This is where the
    coincidence of Imp states and Vminus memory comes into play.)

<div class="paragraph"> </div>

    There are a few other details that are needed for proving correct
    compilation for <span class="inlinecode"><span class="id" type="var">com</span></span>.  But the above is the crux. 
<div class="paragraph"> </div>

 Looking at <span class="inlinecode"><span class="id" type="var">comp_correct</span></span>, it is clear that we need to generate
    more than just the things we had before. In particular, it would
    seem at first that we need several new generators:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">uid</span></span>

</li>
<li> CFG (<span class="inlinecode"><span class="id" type="var">ListCFG.t</span></span>)

</li>
<li> Vminus states

</li>
<li> values (<span class="inlinecode"><span class="id" type="var">val</span></span>)

</li>
</ul>

<div class="paragraph"> </div>

    But note that the only value here, <span class="inlinecode"><span class="id" type="var">v</span></span>, is computed by <span class="inlinecode"><span class="id" type="var">comp</span></span>, so
    we don't actually need a generator for <span class="inlinecode"><span class="id" type="var">val</span></span>.  Moreover, the CFG
    <span class="inlinecode"><span class="id" type="var">g</span></span> <i>cannot</i> be generated randomly, since it has to satisfy
    <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> &mdash; something that a random CFG is very unlikely to
    do. 
<div class="paragraph"> </div>

<a name="lab164"></a><h4 class="section">Exercise: 2 stars (GenUidInsn)</h4>
 Derive generators and write <span class="inlinecode"><span class="id" type="keyword">Show</span></span> instances for <span class="inlinecode"><span class="id" type="var">uid</span></span> and Vminus <span class="inlinecode"><span class="id" type="var">insn</span></span>.
    Note that it is useful to have custom <span class="inlinecode"><span class="id" type="keyword">Show</span></span> instances that are more 
    descriptive than the default ones.  <span class="proofbox">&#9744;</span> 
<div class="paragraph"> </div>

 For Vminus states, we already have a generator for the <span class="inlinecode"><span class="id" type="var">mem</span></span>
    component.  A generator and Show for <span class="inlinecode"><span class="id" type="var">loc</span></span> are defined in
    <a href="OpSemGen.html"><span class="inlineref">OpSemGen</span></a>, with the following types: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">gen_loc</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;gen_loc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;G&nbsp;loc&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">show_locals</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;show_locals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;loc&nbsp;-&gt;&nbsp;list&nbsp;uid&nbsp;-&gt;&nbsp;string&nbsp;*)</span><br/>
</div>

<div class="doc">
We can then define a generator and a <span class="inlinecode"><span class="id" type="var">show</span></span> function for Vminus
    states, on the fixed domains for <span class="inlinecode"><span class="id" type="var">mem</span></span> and <span class="inlinecode"><span class="id" type="var">loc</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_vminus_state</span> : <span class="id" type="var">G</span> <span class="id" type="var">state</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">mem</span> &lt;- <span class="id" type="var">gen_mem</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">pc</span> &lt;- <span class="id" type="var">arbitrary</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">loc</span> &lt;- <span class="id" type="var">gen_loc</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">ppc</span> &lt;- <span class="id" type="var">arbitrary</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">prev_loc</span> &lt;- <span class="id" type="var">gen_loc</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">mkst</span> <span class="id" type="var">mem</span> <span class="id" type="var">pc</span> <span class="id" type="var">loc</span> <span class="id" type="var">ppc</span> <span class="id" type="var">prev_loc</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">show_vminus_state</span> (<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) : <span class="id" type="var">string</span> :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">show_memory</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;"pc: " ++ <span class="id" type="var">show</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">show_locals</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;"ppc: " ++ <span class="id" type="var">show</span> (<span class="id" type="var">st_ppc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;"prev_loc: " ++ <span class="id" type="var">show_locals</span> (<span class="id" type="var">st_ploc</span> <span class="id" type="var">st</span>))%<span class="id" type="var">string</span>.<br/>
</div>

<div class="doc">
One deficiency of this function is that it only shows <span class="inlinecode"><span class="id" type="var">mem</span></span> and 
    <span class="inlinecode"><span class="id" type="var">loc</span></span> on their respective fixed domains. You may find it more useful 
    to have a general one that takes respective domains as input. 
<div class="paragraph"> </div>

 With these out of the way, we can address the remaining gaps.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Firstly, some of the quantities are computed by a function,
         so it is unnecessary to generate them.

</li>
<li> Secondly, the CFG <span class="inlinecode"><span class="id" type="var">g</span></span> cannot be just <i>any</i> CFG, but one that
         satisfies <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> for the compilation result.  (Random
         generation in the usual way is extremely unlikely to meet
         this condition, so most checks would end up being vacuously
         true.)

</li>
<li> Thirdly, a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the existence of <span class="inlinecode"><span class="id" type="var">st'</span></span> really
         needs to compute it.

</li>
</ul>

<div class="paragraph"> </div>

 Firstly, let us drop the unnecessary quantified variables.

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">comp_correct</span>&nbsp;(<span class="id" type="var">comp</span>&nbsp;:&nbsp;<span class="id" type="var">FRESH</span>&nbsp;(<span class="id" type="var">val</span>&nbsp;*&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>&nbsp;:&nbsp;<span class="id" type="var">mem</span>&nbsp;→&nbsp;<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;(<span class="id" type="var">cs</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">uid</span>)&nbsp;(<span class="id" type="var">g</span>:&nbsp;<span class="id" type="var">ListCFG.t</span>)&nbsp;(<span class="id" type="var">k</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;(<span class="id" type="var">st</span>:&nbsp;<span class="id" type="var">state</span>),<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span>&nbsp;(<span class="id" type="var">cs'</span>,&nbsp;(<span class="id" type="var">v</span>,&nbsp;<span class="id" type="var">is</span>))&nbsp;:=&nbsp;<span class="id" type="var">comp</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st</span>)&nbsp;(<span class="id" type="var">is</span>&nbsp;++&nbsp;<span class="id" type="var">k</span>)&nbsp;→<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∃&nbsp;<span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;=&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">k</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">star</span>&nbsp;(<span class="id" type="var">Opsem.step</span>&nbsp;<span class="id" type="var">g</span>)&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_val</span>&nbsp;(<span class="id" type="var">st_loc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">v</span>&nbsp;=&nbsp;<span class="id" type="var">Some</span>&nbsp;(<span class="id" type="var">eval</span>&nbsp;(<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>))&nbsp;∧<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ids_preserved</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return</span>&nbsp;<span class="id" type="var">cs'</span>&nbsp;<span class="id" type="var">v</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">cs'</span>.
<div class="paragraph"> </div>

</div>
    (This is, of course, not accepted by Coq yet.) 
<div class="paragraph"> </div>

 Secondly, we need to write a custom generator that generates CFGs
    satisfying <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span>. An easy option is to just construct a
    CFG that places the instructions at a given pc.

<div class="paragraph"> </div>

    Let us call this <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg'</span></span> <span class="inlinecode"><span class="id" type="var">pc</span></span> <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode"><span class="id" type="var">k</span></span>, in accordance with
    <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span> <span class="inlinecode"><span class="id" type="var">g</span></span> <span class="inlinecode">(<span class="id" type="var">st_pc</span></span> <span class="inlinecode"><span class="id" type="var">st</span>)</span> <span class="inlinecode">(<span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span>)</span>.  It returns a CFG with a
    single block containing <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span></span> placed at (position) <span class="inlinecode"><span class="id" type="var">pc</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">wrap_code_in_cfg'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">instrs</span> <span class="id" type="var">instrs_after</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">ListCFG.t</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">empty_cfg</span> := [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span>) := <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">blocks</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ListCFG.update</span> <span class="id" type="var">empty_cfg</span> <span class="id" type="var">lbl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">generate_dummy_insns</span> <span class="id" type="var">offset</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">instrs</span> ++ <span class="id" type="var">instrs_after</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">lbl</span>, <span class="id" type="var">blocks</span>).<br/>
</div>

<div class="doc">
One fine point is that, because <span class="inlinecode"><span class="id" type="var">pc</span></span> may have a positive offset
    into the block, we also need <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg'</span></span> to fill the
    initial instructions with some dummy instructions (that won't be
    executed). 
<div class="paragraph"> </div>

 Our checkable-lemma-in-progress now looks like this:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">comp_correct</span>&nbsp;(<span class="id" type="var">comp</span>&nbsp;:&nbsp;<span class="id" type="var">FRESH</span>&nbsp;(<span class="id" type="var">val</span>&nbsp;*&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>&nbsp;:&nbsp;<span class="id" type="var">mem</span>&nbsp;→&nbsp;<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;(<span class="id" type="var">cs</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">uid</span>)&nbsp;(<span class="id" type="var">k</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>),&nbsp;∀&nbsp;(<span class="id" type="var">st</span>:&nbsp;<span class="id" type="var">state</span>),<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span>&nbsp;(<span class="id" type="var">cs'</span>,&nbsp;(<span class="id" type="var">v</span>,&nbsp;<span class="id" type="var">is</span>))&nbsp;:=&nbsp;<span class="id" type="var">comp</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span>&nbsp;<span class="id" type="var">g</span>&nbsp;:=&nbsp;<span class="id" type="var">wrap_code_in_cfg'</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st</span>)&nbsp;<span class="id" type="var">is</span>&nbsp;<span class="id" type="var">k</span>&nbsp;<span class="id" type="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∃&nbsp;<span class="id" type="var">st'</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;=&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">k</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">star</span>&nbsp;(<span class="id" type="var">Opsem.step</span>&nbsp;<span class="id" type="var">g</span>)&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_val</span>&nbsp;(<span class="id" type="var">st_loc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">v</span>&nbsp;=&nbsp;<span class="id" type="var">Some</span>&nbsp;(<span class="id" type="var">eval</span>&nbsp;(<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>))&nbsp;∧<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ids_preserved</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return</span>&nbsp;<span class="id" type="var">cs'</span>&nbsp;<span class="id" type="var">v</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">cs'</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 Thirdly, we know that <span class="inlinecode"><span class="id" type="var">st'</span></span> is given by executing the compilation
    result; this is the point of "loading" the compilation result at
    the current <span class="inlinecode"><span class="id" type="var">pc</span></span> in <span class="inlinecode"><span class="id" type="var">g</span></span>, and is of course also stated by
    <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">Opsem.step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span>. So we need an executable evaluator
    for Vminus. The state <span class="inlinecode"><span class="id" type="var">st'</span></span> is obtained by running this evaluator
    until we reach (the start of) <span class="inlinecode"><span class="id" type="var">k</span></span>.

<div class="paragraph"> </div>

    The simplest way of doing so is to stop at the program counter
    that begins <span class="inlinecode"><span class="id" type="var">k</span></span>, and this is actually determined by the CFG that
    loaded <span class="inlinecode"><span class="id" type="var">is</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" type="var">k</span></span>.

<div class="paragraph"> </div>

    Hence we change <span class="inlinecode"><span class="id" type="var">wrap_code_in_cfg'</span></span> to return <span class="inlinecode">(<span class="id" type="var">g</span>,</span> <span class="inlinecode"><span class="id" type="var">pc</span>)</span>, where the
    latter is the <span class="inlinecode"><span class="id" type="var">pc</span></span> that begins <span class="inlinecode"><span class="id" type="var">k</span></span>... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">instrs</span> <span class="id" type="var">instrs_after</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">ListCFG.t</span> * <span class="id" type="var">pc</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">empty_cfg</span> := [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span>) := <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">blocks</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ListCFG.update</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">empty_cfg</span> <span class="id" type="var">lbl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">generate_dummy_insns</span> <span class="id" type="var">offset</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">instrs</span> ++ <span class="id" type="var">instrs_after</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;((<span class="id" type="var">lbl</span>, <span class="id" type="var">blocks</span>), (<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span> + <span class="id" type="var">List.length</span> <span class="id" type="var">instrs</span>)).<br/>
</div>

<div class="doc">
Next we need the evaluator itself (the definitions are in
    <a href="VminusOpSem.html"><span class="inlineref">VminusOpSem</span></a>). 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">eval_until_pc</span>.<br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eval_until_pc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ListCFG.t&nbsp;-&gt;&nbsp;state&nbsp;-&gt;&nbsp;pc&nbsp;-&gt;&nbsp;nat&nbsp;-&gt;&nbsp;err&nbsp;state&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">eval_step</span>.<br/>
<span class="comment">(*&nbsp;===&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eval_step<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ListCFG.t&nbsp;-&gt;&nbsp;state&nbsp;-&gt;&nbsp;err&nbsp;state&nbsp;*)</span><br/>
</div>

<div class="doc">
Now the lemma is:

<div class="paragraph"> </div>

<div class="code code-tight">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span>&nbsp;<span class="id" type="var">comp_correct</span>&nbsp;(<span class="id" type="var">comp</span>&nbsp;:&nbsp;<span class="id" type="var">FRESH</span>&nbsp;(<span class="id" type="var">val</span>&nbsp;*&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>&nbsp;:&nbsp;<span class="id" type="var">mem</span>&nbsp;→&nbsp;<span class="id" type="var">nat</span>)&nbsp;:&nbsp;<span class="id" type="keyword">Prop</span>&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;(<span class="id" type="var">cs</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">uid</span>)&nbsp;(<span class="id" type="var">k</span>:&nbsp;<span class="id" type="var">list</span>&nbsp;<span class="id" type="var">insn</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀&nbsp;(<span class="id" type="var">st</span>:&nbsp;<span class="id" type="var">state</span>),<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span>&nbsp;(<span class="id" type="var">cs'</span>,&nbsp;(<span class="id" type="var">v</span>,&nbsp;<span class="id" type="var">is</span>))&nbsp;:=&nbsp;<span class="id" type="var">comp</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span>&nbsp;(<span class="id" type="var">g</span>,&nbsp;<span class="id" type="var">endpoint</span>)&nbsp;:=&nbsp;<span class="id" type="var">wrap_code_in_cfg</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st</span>)&nbsp;<span class="id" type="var">is</span>&nbsp;<span class="id" type="var">k</span>&nbsp;<span class="id" type="keyword">in</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span>&nbsp;<span class="id" type="var">eval_until_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">cutpoint</span>&nbsp;1000&nbsp;<span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">inl</span>&nbsp;<span class="id" type="var">err</span>&nbsp;⇒&nbsp;<span class="id" type="var">false</span>&nbsp;<span class="comment">(*&nbsp;either&nbsp;out&nbsp;of&nbsp;fuel&nbsp;or&nbsp;no&nbsp;st'&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;<span class="id" type="var">inr</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;⇒&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;=&nbsp;<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc</span>&nbsp;<span class="id" type="var">g</span>&nbsp;(<span class="id" type="var">st_pc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">k</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">star</span>&nbsp;(<span class="id" type="var">Opsem.step</span>&nbsp;<span class="id" type="var">g</span>)&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_val</span>&nbsp;(<span class="id" type="var">st_loc</span>&nbsp;<span class="id" type="var">st'</span>)&nbsp;<span class="id" type="var">v</span>&nbsp;=&nbsp;<span class="id" type="var">Some</span>&nbsp;(<span class="id" type="var">eval</span>&nbsp;(<span class="id" type="var">st_mem</span>&nbsp;<span class="id" type="var">st</span>))&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ids_preserved</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">st</span>&nbsp;<span class="id" type="var">st'</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return</span>&nbsp;<span class="id" type="var">cs'</span>&nbsp;<span class="id" type="var">v</span>&nbsp;∧<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr</span>&nbsp;<span class="id" type="var">cs</span>&nbsp;<span class="id" type="var">cs'</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.
<div class="paragraph"> </div>

</div>

<div class="paragraph"> </div>

 At this point, the major obstacles are out of the way; we just
    have to write a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for the big conjunction. Because it is
    big, it is easier to write a <span class="inlinecode"><span class="id" type="var">Checker</span></span> for each conjunct rather
    than one monolithic checker.

<div class="paragraph"> </div>

    That is, we need to define:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> that checks that two memories are the same. This
        has already been done.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> that checks for <span class="inlinecode"><span class="id" type="var">insns_at_pc</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> for <span class="inlinecode"><span class="id" type="var">ids_preserved</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> for <span class="inlinecode"><span class="id" type="var">good_return</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> for <span class="inlinecode"><span class="id" type="var">ctxt_incr</span></span>.

</li>
<li> A <span class="inlinecode"><span class="id" type="var">Checker</span></span> that checks for equality between the two results
        of evaluation. 
</li>
</ul>

<div class="paragraph"> </div>

 (Note that <span class="inlinecode"><span class="id" type="var">star</span></span> <span class="inlinecode">(<span class="id" type="var">Opsem.step</span></span> <span class="inlinecode"><span class="id" type="var">g</span>)</span> <span class="inlinecode"><span class="id" type="var">st</span></span> <span class="inlinecode"><span class="id" type="var">st'</span></span> doesn't need
    checking, because it is implicit in <span class="inlinecode"><span class="id" type="var">eval_until_pc</span></span>.) 
<div class="paragraph"> </div>

 The remaining ones are defined below.  All are fairly
    straightforward. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">loc_on_domain_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span> : <span class="id" type="var">loc</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">dom</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a</span> :: <span class="id" type="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">loc1</span> <span class="id" type="var">a</span>, <span class="id" type="var">loc2</span> <span class="id" type="var">a</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n<sub>1</sub></span>, <span class="id" type="var">Some</span> <span class="id" type="var">n<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">Nat.eqb</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> <span class="id" type="keyword">then</span> <span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> "loc_equal: locs disagree" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span>, <span class="id" type="var">None</span> ⇒ <span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">whenFail</span> "loc_equal: locs disagree" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">insns_at_pc_checker</span> `{<span class="id" type="keyword">Show</span> <span class="id" type="var">pc</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">k</span> : <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">k</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">uid</span>, <span class="id" type="var">cmd</span>) :: <span class="id" type="var">instrs</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">ListCFG.fetch</span> <span class="id" type="var">g</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">uid'</span>, <span class="id" type="var">cmd'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_cmd</span> <span class="id" type="var">cmd</span> <span class="id" type="var">cmd'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">insns_at_pc_checker</span> <span class="id" type="var">g</span> (<span class="id" type="var">incr_pc</span> <span class="id" type="var">p</span>) <span class="id" type="var">instrs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("insns_at_pc: cmd at pc "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">show</span> <span class="id" type="var">p</span>) ++ " not equal") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("insns_at_pc: uid at pc "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">show</span> <span class="id" type="var">p</span>) ++ "not equal") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "insns_at_pc: cannot fetch" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">ids_preserved_checker</span> (<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">st</span> <span class="id" type="var">st'</span>: <span class="id" type="var">state</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">cs</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) (<span class="id" type="var">st_loc</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">good_return_checker</span> (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">val</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">v</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">val_uid</span> <span class="id" type="var">uid</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "good_return: cannot find value" <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">List.existsb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uid'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>) <span class="id" type="var">cs</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">val_nat</span> <span class="id" type="var">n</span> ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">ctx_incr_checker</span> (<span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">cs</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">uid</span> :: <span class="id" type="var">uids</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">List.existsb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uid'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>) <span class="id" type="var">cs'</span>) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr_checker</span> <span class="id" type="var">uids</span> <span class="id" type="var">cs'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("ctx_incr: " ++ <span class="id" type="var">show</span> <span class="id" type="var">uid</span> ++ " not found") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">eval_equal_checker</span> (<span class="id" type="var">eval</span>: <span class="id" type="var">mem</span> → <span class="id" type="var">nat</span>) (<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">run_result</span> := <span class="id" type="var">eval_val</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) <span class="id" type="var">v</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">expected_result</span> := <span class="id" type="var">eval</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">run_result</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "eval_equal: evaluation value not the same"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Nat.eqb</span> <span class="id" type="var">n</span> <span class="id" type="var">expected_result</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "eval_equal: run did not obtain any value" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We can now compose all these checkers using QuickChick's <span class="inlinecode"><span class="id" type="var">conjoin</span></span>
    combinator. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">expression_step_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>: <span class="id" type="var">mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">initial_state</span> <span class="id" type="var">final_state</span>: <span class="id" type="var">state</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">k</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) (<span class="id" type="var">end_of_expr</span>: <span class="id" type="var">pc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">v</span> : <span class="id" type="var">val</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">conjoin</span> [<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ids_preserved_checker</span> <span class="id" type="var">cs</span> <span class="id" type="var">initial_state</span> <span class="id" type="var">final_state</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">end_of_expr</span> <span class="id" type="var">k</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return_checker</span> <span class="id" type="var">cs'</span> <span class="id" type="var">v</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr_checker</span> <span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_equal_checker</span> <span class="id" type="var">eval</span> <span class="id" type="var">final_state</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;].<br/>
</div>

<div class="doc">
At last, we can assemble a checker for <span class="inlinecode"><span class="id" type="var">comp_correct</span></span> as follows. 
<div class="paragraph"> </div>

 (It is convenient to split the <span class="inlinecode"><span class="id" type="var">Checker</span></span> into a part that does
    only the generation and a second part that does the checking,
    because a type error can cause the typechecker to get stuck trying
    to resolve the issue by looking for typeclass instances that don't
    exist.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp</span>: <span class="id" type="var">FRESH</span> (<span class="id" type="var">val</span> * <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)) (<span class="id" type="var">eval</span>: <span class="id" type="var">mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) (<span class="id" type="var">k</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">cs'</span>, (<span class="id" type="var">v</span>, <span class="id" type="var">instrs</span>)) := <span class="id" type="var">comp</span> <span class="id" type="var">cs</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">endpoint</span>) := <span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">st</span>) <span class="id" type="var">instrs</span> <span class="id" type="var">k</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval_until_pc</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="var">endpoint</span> 1000 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">whenFail</span> ("comp_correct_checker: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">st'</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">expression_step_checker</span> <span class="id" type="var">eval</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">k</span> <span class="id" type="var">endpoint</span> <span class="id" type="var">cs</span> <span class="id" type="var">cs'</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_correct_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp</span>: <span class="id" type="var">FRESH</span> (<span class="id" type="var">val</span> * <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)) (<span class="id" type="var">eval</span>: <span class="id" type="var">mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">extra_insn</span> : <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> <span class="id" type="var">gen_vminus_state</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ [])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">show_vminus_state</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">start_state</span>: <span class="id" type="var">state</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp</span> <span class="id" type="var">eval</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">cs</span> <span class="id" type="var">start_state</span> <span class="id" type="var">extra_insn</span>))).<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" type="var">comp_aexp</span></span> checker is now just a simple wrapper. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_aexp_correct_checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrink</span> (<span class="id" type="var">resize</span> 3 <span class="id" type="var">arbitrary</span>) <span class="id" type="var">shrink</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span>: <span class="id" type="var">aexp</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker</span> (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a</span>) (<span class="id" type="var">aeval</span> <span class="id" type="var">a</span>)).<br/>

<br/>
<span class="comment">(*!&nbsp;QuickChick&nbsp;comp_aexp_correct_checker.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;===&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;QuickChecking&nbsp;comp_aexp_correct_checker<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+++&nbsp;Passed&nbsp;10000&nbsp;tests&nbsp;(0&nbsp;discards)<br/>
*)</span><br/>
</div>

<div class="doc">
<a name="lab165"></a><h4 class="section">Exercise: 2 stars (add_aexp_mutants)</h4>
 Since the compiler has already been proven correct, we'd expect
    the above test to succeed. However, it could be succeeding for
    silly reasons (because our test-case generation is bad or the
    distribution of tests is skewed in some way), so we'd also like to
    know that the <span class="inlinecode"><span class="id" type="var">Checker</span></span> indeed fails when the compiler is wrong.

<div class="paragraph"> </div>

    Change the definition of <span class="inlinecode"><span class="id" type="var">compile_aexp</span></span> in <a href="Compiler.html"><span class="inlineref">Compiler</span></a> to
    misbehave in some way (two suggestions can be found in a comment
    there), recompile that file, then come back here and check that
    the QuickChick command above can find the bug. 
<div class="paragraph"> </div>

<a name="lab166"></a><h4 class="section">Exercise: 2 stars (compBopCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_bop_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and
    make sure that all tests pass. Next, mutate <span class="inlinecode"><span class="id" type="var">comp_bop</span></span> in
    <span class="inlinecode"><span class="id" type="var">Compiler.v</span></span> to do something wrong (a suggestion is provided, but
    again you can make up your own as well), and use QuickChick to
    test the Checker again. Do you get a nice-looking counterexample,
    and can you explain why it fails? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab167"></a><h4 class="section">Exercise: 2 stars (compBexpCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_bexp_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and
    make sure that all tests pass. Next, mutate <span class="inlinecode"><span class="id" type="var">comp_bexp</span></span> in
    <span class="inlinecode"><span class="id" type="var">Compiler.v</span></span> to do something wrong, and QuickChick your checker
    again. Do you get a useful counterexammple? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab168"></a><h4 class="section">Exercise: 3 stars (compStoreCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_store_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and
    make sure that all tests pass. Next, mutate <span class="inlinecode"><span class="id" type="var">comp_store</span></span> in
    <span class="inlinecode"><span class="id" type="var">Compiler.v</span></span> to do something wrong and QuickChick your Checker
    again.  Are you happy? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab169"></a><h4 class="section">Exercise: 3 stars (compCondCorrect)</h4>
 Write a Checker for <span class="inlinecode"><span class="id" type="var">comp_cond_correct</span></span> in <span class="inlinecode"><span class="id" type="var">CompilerProp.v</span></span>, and
    make sure that all tests pass. Next, mutate <span class="inlinecode"><span class="id" type="var">comp_cond</span></span> in
    <span class="inlinecode"><span class="id" type="var">Compiler.v</span></span> to do something wrong and QuickChick your checker
    again. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab170"></a><h4 class="section">Exercise: 5 stars (check_type_safety)</h4>

</div>
<div class="code code-space">
<span class="comment">(*&nbsp;Build&nbsp;checkers&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;<span class="inlinecode"><span class="id" type="tactic">progress</span></span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" type="var">preservation</span></span><br/>
&nbsp;&nbsp;&nbsp;properties&nbsp;in&nbsp;<a href="VminusStatics.html"><span class="inlineref">VminusStatics</span></a>.&nbsp;&nbsp;Mutate&nbsp;some&nbsp;of&nbsp;the&nbsp;definitions<br/>
&nbsp;&nbsp;&nbsp;to&nbsp;introduce&nbsp;bugs&nbsp;and&nbsp;see&nbsp;if&nbsp;you&nbsp;can&nbsp;find&nbsp;them.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>