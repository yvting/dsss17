(** * CompilerProp: Correctness of the Imp Compiler *)
Require Import FunctionalExtensionality. (* TODO: don't really need this *)
Require Import List.
Import ListNotations.
Require Import RelationClasses.


Require Import Vminus.Util Vminus.Classes.
Require Import Vminus.Vminus.
Require Import Vminus.CFG.
Require Import Vminus.ListCFG.
Require Import Vminus.Sequences.
Require Import Vminus.VminusOpSem.
Require Import Vminus.Imp.
Require Import Vminus.Compiler.
Import ListCFG.
Import V.Opsem.

Set Bullet Behavior "Strict Subproofs".
Unset Printing Records.

(* ################################################################# *)
(** * Imp to Vminus Compiler Correctness *)

(** This file proves the correctness of the Imp to Vminus compiler.  It follows
the general strategy outlined by Xavier Leroy's DeepSpec Summer School lectures.
The final simulation diagram is given in terms of the same [Sequences]
definitions used in those lectures.

There are a few challenges in proving that this compiler is correct:

 - relating the output of the compiler to its representation as a ListCFG

 - setting up the correctness statements so that they are strong enough to prove
   by induction

 - defining a simulation relation between the source Imp program and the Vminus
   version after compilation

 - dealing with the fact that the compiler is monadic -- we need to show that
   its state evolves only _monotonically_

*)

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Sequences *)

(** This development re-uses the [Sequences] file from by Xavier Leroy's DSSS17
compiler.  For our purposes, we need:

  - [star (step g)] : the reflexive, transitive closure of the Vminus [step g]
    relation (zero or more steps)

  - [plus (step g)] : the transitive closure of [step] (one or more steps)

  - [infseq (step g) s] : predicate saying that there's an infinite sequence of
    steps starting from [s]

*)

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Expression Compilation Properties *)

(** We start by building up the properties needed to prove that the
compiler generates correct Vminus code when compiling an expression.
Intuitively, it should suffice to say that if the Imp evaluator says that an
expression [a:aexp] evaluates to [n], then the corresponding code emitted by the
compiler computes [n] and returns it as a Vminus value (either as a literal or
in a local identifier).

However, to prove that, we need to strengthen the invariants so that the
induction will go through.  In particular, we need to know that the generated
code doesn't alter the state of the Vminus memory, that the code doesn't
(somehow) change the bindings of local variables in the environment, and that
the compiler doesn't lose any information about the freshness of the [uid]'s
that it has generated.  
*)

(** 
- The value of any uid bound by the local environment before the expression
is computed remains unchanged after the expression is computed.
*)

Definition ids_preserved (cs:list uid) (st st':state) : Prop :=
  forall uid n, In uid cs -> 
    st_loc st uid = Some n -> st_loc st' uid = Some n.


(** 
-If the result is stored in a local uid, then it must be in the list of uids
generated by the compiler. *)

Definition good_return (cs:list uid) (v:val) : Prop :=
  forall uid, v = val_uid uid -> In uid cs.

(** 
- Moreover, the set of fresh uids generated during compilation grows
monotonically. *)

Definition ctx_incr (cs cs':list uid) : Prop :=
  forall uid, In uid cs -> In uid cs'.

Instance ctx_incr_trans : Transitive ctx_incr.
Proof. red; unfold ctx_incr; intuition. Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * General expression compilation correctness *)

(** We can abstract the definition of correctness with respect to the compiler
computation and the Imp evaluator used to give meaning to the expression.

We also have to generalize the statement of correctness so that it takes place
in a context [k] of instructions to continue with after the expression finishes
evaluating. *)

Definition comp_correct (comp : FRESH (val * list insn))
                        (eval : mem -> nat) : Prop :=
  forall cs cs' g st is k v,
  (cs', (v, is)) = comp cs ->                
  insns_at_pc g (st_pc st) (is ++ k) ->      
  exists st',
    st_mem st' = st_mem st /\   (* <---- the memory is unchanged *)
    ListCFG.insns_at_pc g (st_pc st') k /\  (* <--- the code ran *)
    star (step g) st st' /\       (* <---- the Vminus machine steps *)
    ids_preserved cs st st' /\
    good_return cs' v /\
    ctx_incr cs cs' /\
    eval_val (st_loc st') v = Some (eval (st_mem st)).  (* <- right ans! *)

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Star vs. Plus *)
(** **** Exercise: 1 star, recommended (why star?)  *)
(** Why do we use [star] in the definition of correctness? Would [plus] work? *)

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Binop Compilation Correctness *)

(** Assuming we have the correct compilations of two subexpressions, we 
can use [comp_bop] to correctly compile a binary operation.  

It is worth stepping through this proof to see how the simulation works -- we 
first extract information from the compiled code and then step the Vminus 
state forward to trace the execution through the program.

The induction hypotheses let us use transitivity to compose together the 
executions of the two sub expressions.  
*)

Lemma comp_bop_correct : forall b comp1 comp2 eval1 eval2
    (IHa1: comp_correct comp1 eval1)
    (IHa2: comp_correct comp2 eval2),
    comp_correct (comp_bop b comp1 comp2)
                 (fun m => bop_denote b (eval1 m) (eval2 m)).
Proof.
  unfold comp_correct. 
  intros b comp1 comp2 eval1 eval2.
  intros until v. intros Hcomp Hinsns.

  (* Extract information from the compiler *)

  unfold comp_bop in Hcomp.
  simpl in Hcomp. 
  destruct (comp1 cs) as [cs1 [rl1 rr1]] eqn:Hc1.
  destruct (comp2 cs1) as [cs2 [rl2 rr2]] eqn:Hc2.
  inversion Hcomp; clear Hcomp.
  subst.

  (* Normalize the code *)
  repeat rewrite <- app_assoc in Hinsns.

  (* Instatiate the first induction hypothesis: the automation uses Hc1 and
  Hinsns to deduce the instantiation.*)
  eelim IHa1; [| eauto ..]. 
  intros st1 (Hinv1 & His1 & Hstep1 & Hpres1 & Hret1 & Hincr1 & Heval1).

  (* Now the automation will find Hc2 and His1 *)
  eelim IHa2; [| eauto ..]. 
  intros st2 (Hinv2 & His2 & Hstep2 & Hpres2 & Hret2 & Hincr2 & Heval2).
  clear IHa1 IHa2.

  (* Now we need to insantiate the existential with the new state. 
     First we destruct st2 -- which is the state that results after
     having computed both subexpressions -- but we remember its name.
   *)
  rename st2 into st2'.  set (st2:=st2') in *.  destruct st2'.

  (* We know that the program count will increment and that the local environment
  will be extended with the result of the bop.  *)
  eexists {| st_pc  := incr_pc (st_pc st2);
             st_loc := Locals.update (st_loc st2) (Uid.fresh cs2) _ |}.
  simpl.

  (* Now we have to establish that all of the properties hold of the resulting state. *)
  split.
  -  (* The memory doesn't change. *)

    transitivity (st_mem st1). transitivity (st_mem st2). reflexivity. assumption. assumption.

  - repeat split.
    + (* The program counter advances as required. *)
      inversion His2; auto.

    + (* We need two uses of transitivity plus one additional step to account
         for the steps taken by the Vminus code to simulate the full *)
      eapply star_trans; eauto. eapply star_trans; eauto.
      eapply star_one. eapply step_bop. inversion His2; eauto.  
      unfold eval_bop. simpl in Heval2. rewrite Heval2. 
      replace (eval_val st_loc0 _) with (Some (eval1 (st_mem st))).
      reflexivity. symmetry. 

      (* We need to use the fact that the first expression evaluates to the same value
         in the new execution context. *)
      destruct rl1; auto. simpl. 
      unfold good_return in *.
      assert (In t0 cs1). apply Hret1; auto.
      unfold ids_preserved in Hpres2.
      apply Hpres2. auto. auto.

    + (* We need to use the freshness of the newly generated uid to show that
         the updated local environment preserves all the old values. *)
      red;  simpl; intros uid n H H0.  rewrite Locals.update_neq.
      change st_loc0 with (st_loc st2).
      apply Hpres2; auto. apply Hincr1, Hincr2 in H.
      inversion Hc2. contradict H. rewrite <- H. apply Uid.fresh_not_in.

    (* monotonicity of the state is easy to show *)
    + red. intros uid' Hid. injection Hid; inversion Hc2. left; auto.

    + transitivity cs1; auto. transitivity cs2; auto. 
      unfold ctx_incr. inversion Hc2; intros. right; auto.

    (* as is that we got the right answer! *)
    + rewrite Locals.update_eq.
      replace (st_mem st1) with (st_mem st). subst. reflexivity. 
      reflexivity.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Aexp Compilation Correctness *)

(** Assuming we have the correct compilations of two subexpressions, we can use
[comp_bop] to correctly compile a binary operation. *)

(** **** Exercise: 3 stars: (comp_aexp_correct)  *)

(** The new interesting case is handling the Imp identifiers, which compile to a
[load] instruction.  The approach is quite similar to the proof of the binop
correctness.  Using it as a guideline, complete the case for AIds in the 
proof below. *)

Lemma comp_aexp_correct : forall (a:aexp),
  comp_correct (comp_aexp a) (aeval a).
Proof.
  (* comp_bop_correct takes care of all the inductive cases *)
  induction a; [ | | eapply comp_bop_correct; auto ..].

  - (* Case "ANum". *)
  unfold comp_correct; intros. inversion H; subst; clear H. 
  exists st. repeat split; try red; auto using star_refl. discriminate.

  
  - (* Case "AId". *)
  (* FILL IN HERE *) Admitted.

Local Hint Resolve comp_aexp_correct.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Bexp Compilation Correctness *)

(** Proving the correctness of boolean expression compilation follows
analogously to that of aexps. *)

Lemma comp_bexp_correct : forall (b:bexp),
  comp_correct (comp_bexp b) (fun m => b2n (beval b m)).
Proof.
  induction b.

  - (* Case "BTrue". *)
  unfold comp_correct; intros. inversion H; subst; clear H. 
  exists st; repeat split; try red; auto using star_refl. discriminate.

  - (* Case "BFalse". *)
  unfold comp_correct; intros. inversion H; subst; clear H. 
  exists st; repeat split; try red; auto using star_refl. discriminate.

  - (* Case "BEq". *)
  eapply (comp_bop_correct bop_eq); auto.

  - (* Case "BLe". *)
  eapply (comp_bop_correct bop_le); auto.

  - (* Case "BNot". *)
  simpl. evar (SPEC : mem -> nat). replace (fun (m:mem) => b2n _) with SPEC.
  subst SPEC. apply (comp_bop_correct bop_eq); eauto.
  unfold comp_correct; intros. inversion H; subst; clear H.
  instantiate (1:=fun m => 0).
  exists st; repeat split; try red; auto using star_refl. discriminate.
  unfold SPEC. apply functional_extensionality. intro.
  destruct (beval b x); auto.

  - (* Case "BAnd". *)
  simpl. evar (SPEC : mem -> nat). replace (fun (m:mem) => b2n _) with SPEC.
  subst SPEC. apply (comp_bop_correct bop_and); eauto.
  subst SPEC. apply functional_extensionality. intro. 
  simpl. destruct (beval b1 x), (beval b2 x); auto.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Tactic Support *)

(** As we begin to prove more lemmas about our compiler, we'll see that the
first step is usually to exploit facts about the compiler implementation, which
amounts to "walking through" the behavior of the compiler on the given inputs.

This means that we investigate the compiler state state, exposing the various
[let] bindings, which are under the hood of the state monad, and destructing
those too.

In practice, we arrived at this tactic by manually stepping through several of
the cases of our proofs and noticing the common pattern of destruction.
*)

Ltac exploit_compile :=
  repeat
    match goal with
    | [ x : Compiler.cstate |- _] => destruct x as [[?lbls ?ids] ?bs] 
    | [ H : context[let (_,_) := ?x in _] |- _] => destruct x as [?l ?r] eqn:?Heq
    | [ H : (_, _) = (_, _) |- _] => inversion H; subst; clear H
    | [ H : () |- _ ] => destruct H
    end.


(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Store Command Correctness *)

(** Following the structure of the compiler, we now state a lemma that
establishes the correctness of the function that compiles a [store].  There are
a couple of things to note:

 - first, this lemma assumes that the code for the store resides at the start of
   the block
 
 - second, we know that the store command takes at least one Vminus instruction,
   so we can use [plus]

The lemma says that the memory in the state after the assignment contains the
value obtained by evaluating [a] in the original state, according to Imp
semantics.  
*)

Lemma comp_store_correct : 
  forall g (a:aexp) v le lr cs st,
  insns_at_pc g (block_entry le) (strun (comp_store a v lr) cs) ->
  st_pc st = (block_entry le) ->
  exists st',
    plus (step g) st st' /\
    st_pc st' = (block_entry lr) /\
    st_mem st' = (Memory.update (st_mem st) v (aeval a (st_mem st))).
Proof.
  intros g a v le lr cs st H H0. 
  unfold strun, comp_store in H. simpl in H. 
  exploit_compile.
  
  rewrite <- H0 in H.
  eelim (comp_aexp_correct a); eauto.
  intros st' H'. decompose [and] H'; clear H'.
  rename st' into st''. set (st' := st'') in *. destruct st''.

  eexists.
  split.

  - eapply plus_star_trans'. eauto. 
    eapply plus_left. eapply step_store. apply H3. eauto.
    eapply star_step. eapply step_tmn. inversion H3. apply H9.
    reflexivity.
    eapply star_refl.

  - split.
    + reflexivity.
    + rewrite <- H1. reflexivity.
Qed.


(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Conditionals *)

(** **** Exercise: 3 stars: (comp_cond_correct)  *)

(** The correctness of the function that compiled conditionals follows
the same structure as that of [comp_store_correct]. Using it as a guideline, 
complete the proof below.
*)

Lemma comp_cond_correct :
  forall g cs b le l1 l2 st,
  insns_at_pc g (block_entry le) (strun (comp_cond b l1 l2) cs) ->
  st_pc st = (block_entry le) ->
  exists st',
    plus (step g) st st' /\
    st_pc st' = block_entry (if beval b (st_mem st) then l1 else l2) /\
    st_mem st = st_mem st'.
Proof.
(* FILL IN HERE *) Admitted.
  
(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Correctness of the Compiler *)

(** As we saw in Xavier's lectures, Vminus is deterministic so it suffices to
show a forward simulation to prove desired correspondence between Imp and its
Vminus form.  The first big task in doing that is to somehow relate an Imp
command to the code generated by the compiler.

Since our compiler generates explicitly named blocks, we can use the labels to
help line up the Vminus code.
*)

(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Simulation relation. *)

(** Relate Imp commands to sequences of basic blocks in the cfg. 

  [match_config cmd g l r] means that the Imp command [cmd] resides as Vminus code
  in ListCFG [g] at a block labeled [l] and exits via label [r].
*)

Open Scope imp_scope.

Inductive match_config : Imp.com -> (ListCFG.t * lbl * lbl) -> Prop :=
  | MC_Skip : forall bs l,
      match_config SKIP (bs, l, l)
  | MC_Ass : forall g l l' uid a cs,
      insns_at_pc g (block_entry l) (strun (comp_store a uid l') cs) ->
      match_config (CAss uid a) (g, l, l')
  | MC_Seq : forall g l1 l2 l3 c1 c2,
      match_config c1 (g, l1, l2) ->
      match_config c2 (g, l2, l3) ->
      match_config (CSeq c1 c2) (g, l1, l3)
  | MC_If : forall g le lr l1 l2 b c1 c2 cs,
      match_config c1 (g, l1, lr) ->
      match_config c2 (g, l2, lr) ->
      insns_at_pc g (block_entry le) (strun (comp_cond b l1 l2) cs) ->
      match_config (CIf b c1 c2) (g, le, lr)
  | MC_While : forall g le lb lr b c cs,
      match_config c (g, lb, le) ->
      insns_at_pc g (block_entry le) (strun (comp_cond b lb lr) cs) ->
      match_config (CWhile b c) (g, le, lr).

Local Hint Constructors match_config.


(**  ------------------------------------------------------------------------- *)
(* ----------------------------------------------------------------- *)
(** *** Lift the relation to whole states *)

(** 
  - the Imp memory and the Vminus memory must be the same

  - the program counter is at the entry of a block labeled [l]

  - the Vminus code at that resides at block [l] matches the Imp command
*)

Inductive match_states (g:ListCFG.t) (r:lbl)
  : (com * Imp.state) -> state -> Prop :=
  match_states_intro : forall c mem st l,
    match_config c (g, l, r) ->
    st_pc st = block_entry l ->
    st_mem st = mem ->
    match_states g r (c, mem) st.


(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Translation simulation: First try. *)

(** Given the definition of [match_states] it is not too hard to prove that one step of the 
Imp small-step semantics can be simulated by (zero or more) steps of the Vminus semantics.
*)


Lemma simulation_step' :
  forall g s s' st r,
  Imp.step s s' ->
  match_states g r s st ->
  exists st',
    star (step g) st st' /\
    match_states g r s' st'.
Proof.
  intros g s s' st r Hstep.
  revert st. revert r.
  
  induction Hstep; intros r vst Hmatch. 
  inversion Hmatch as [? ? ? ? Hm]; inversion Hm; subst.

  - (* Case "S_Ass". *)
  eapply comp_store_correct in H6 as [st' [? [? ?]]]; eauto.
  eexists. split.
    + apply plus_star. apply H.
    + econstructor; eauto. 

  - (* Case "S_Seq". *)
    inversion Hmatch. subst. inversion H1. subst.
    specialize (IHHstep l2 vst). 
    lapply IHHstep.
    intros [vst' [? ?]].
    exists vst'. split; auto.
    inversion H0. subst.
    econstructor; eauto.
    econstructor; eauto. 

  - (* Case "S_SeqSkip". *)
    exists vst. split.
    + apply star_refl.
    + inversion Hmatch; subst.
      inversion H1; subst.
      inversion H4. subst.
      econstructor; eauto.

  - (* Case "S_IfTrue". *)
    inversion Hmatch. subst. inversion H2. subst.
    eapply comp_cond_correct in H10 as [st' [? [? ?]]].
    rewrite H in H1.
    + exists st'. split.
      apply plus_star; eauto. econstructor; eauto.
    + assumption.
    
  - (* Case "S_IfFalse". *)
    inversion Hmatch. subst. inversion H2. subst.
    eapply comp_cond_correct in H10 as [st' [? [? ?]]].
    rewrite H in H1.
    + exists st'. split.
      apply plus_star; eauto. econstructor; eauto.
    + assumption.

  - (* Case "S_While". *)
    inversion Hmatch. subst.
    inversion H1. subst.
    exists vst.
    split.
    + apply star_refl. 
    + econstructor; eauto. 
Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Stuttering *)

(** Recall from Xavier's lectures: The proof above goes through, but does not
    ensure that if the source program diverges the compiled program does not go
    wrong!

    To fix it, we need to ensure that there is no "infinite stuttering" in which
    the source program takes an infinite number of steps while the target
    terminates (or gets stuck).  *)

(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Eliminating Stuttering *)

(** First, we define an appropriate measure of the Imp command that will
decrease whenever the Vminus program takes zero steps. With a bit of
experimenting, we determine that a good candidate is twice the number of [SKIP]
commands plus 1 if the command starts with a [WHILE].  *)

Fixpoint weight_skips (c:com) : nat :=
  match c with
    | (c1 ;; c2) => weight_skips c1 + weight_skips c2
    | SKIP => 2
    | _ => 0
  end.

Fixpoint while_head (c:com) : nat :=
  match c with
    | (c1 ;; _) => while_head c1
    | WHILE _ DO _ END => 1
    | _ => 0
  end.

Definition com_size (c:com) : nat := weight_skips c + while_head c.

(** Lift to Imp states *)

Definition imp_size (st:com * mem) : nat := 
  let (c, _) := st in com_size c.


(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Lemmas about the measure. *)

Require Import Omega.

Lemma while_head_bound : forall c, while_head c < 2.
Proof. induction c; simpl; omega. Qed.

Lemma com_size_seq : forall c1 c1' c2,
  com_size c1' < com_size c1 ->
  com_size (c1';; c2) < com_size (c1;; c2).
Proof.
  unfold com_size; destruct c1, c1'; 
  try solve [simpl; intros; omega].
Qed.

Lemma com_size_seqskip : forall c,
  com_size c < com_size (SKIP;; c).
Proof.
  unfold com_size; destruct c;
  try solve [simpl; try match goal with
                        | |- context[while_head ?X] => 
                             pose proof (while_head_bound X)
                        end; intros; omega].
Qed.

Hint Resolve com_size_seqskip com_size_seq.



(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Refining the simulation proof. *)

(** The stronger statement of simulation shows that the Vminus code takes at
least one step _unless_ the size of the Imp state decreases according to our
measure.  Intuitively: the only Imp commands that can translate to no Vminus
instructions are [SKIP] and, potentially, WHILE FALSE DO C DONE *)

Lemma simulation_step :
  forall g r imp_st imp_st' vmn_st,
  Imp.step imp_st imp_st' ->
  match_states g r imp_st vmn_st ->
  exists vmn_st',
    (plus (step g) vmn_st vmn_st' \/
     star (step g) vmn_st vmn_st' /\ imp_size imp_st' < imp_size imp_st) /\
    match_states g r imp_st' vmn_st'.
Proof.
  intros. generalize dependent vmn_st. revert r.
  
  induction H; intros r vmn_st Hst;
  inversion Hst as [? ? ? ? Hcfg]; inversion Hcfg; subst.

  - (* Case "S_Ass". *)
  eapply comp_store_correct in H6 as [st' [? [? ?]]]; eauto.
  eexists. split; eauto. econstructor; eauto.
  
  - (* Case "S_Seq". *)
  specialize (IHstep l2 vmn_st).
  lapply IHstep. intros [vmn_st' [? ?]]. exists vmn_st'. split. 
  simpl in *; intuition. inversion H2; subst. 
  econstructor; eauto. econstructor; eauto.

  - (* Case "S_SeqSkip". *)
  exists vmn_st. split. right. 
  split. apply star_refl. unfold imp_size. 
  simpl; intuition. inversion H7; subst. econstructor; eauto.

  - (* Case "S_IfTrue". *)
  eapply comp_cond_correct in H13 as [st' [? [? ?]]]; eauto.
  exists st'. split; eauto. econstructor; eauto. 
  rewrite H in H2; auto. 

  - (* Case "S_IfFalse". *)
  eapply comp_cond_correct in H13 as [st' [? [? ?]]]; eauto.
  exists st'. split; eauto. econstructor; eauto.  
  rewrite H in H2; auto. 

  - (* Case "S_While". *)
  exists vmn_st. split. right; intuition. apply star_refl. 
  econstructor; eauto. 
Qed.

(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Relating the initial states *)

(** We still must relate the initial states! *)

(** First, some helpers: these show that compilation of store and conditionals 
is never "trivial" -- we always get some Vminus code.
*)

Lemma comp_store_not_nil : forall a v l cs,
  strun (comp_store a v l) cs <> [].
Proof.
  intros. unfold strun.
  remember (comp_store _ _ _ _) as ma.
  unfold comp_store in Heqma. simpl in Heqma.
  match type of Heqma with context[let (_,_) := ?x in _] => destruct x eqn:Hc end.
  destruct p as [v' is].
  subst ma; simpl. intro.
  eapply app_cons_not_nil; eauto.
Qed.

Lemma comp_cond_not_nil : forall b v l cs,
  strun (comp_cond b v l) cs <> [].
Proof.
  intros. unfold strun.
  remember (comp_cond _ _ _ _) as ma.
  unfold comp_cond in Heqma. simpl in Heqma.
  match type of Heqma with context[let (_,_) := ?x in _] => destruct x eqn:Hc end.
  destruct p as [v' is].
  subst ma; simpl. intro.
  eapply app_cons_not_nil; eauto.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Monotonicity of Compiler State *)

(** Compilation only _extends_ the compilation state:

    - Uids and labels change only monotonically -- we generate new fresh
      identifiers by using [fresh] and add them to the lists of generated uids.

    - Compilation never removes code; it only adds blocks to the CFG.

  There is one subtlety: when compiling a [WHILE] command, the compiler
  "reserves" a block for the entry to the loop.  This block is (temporarily)
  added to the CFG with an empty instruction sequence.  The compiler then 
  recursively compiles the body of the [WHILE], which might add several new blocks,
  after which the loop entry block is filled in.  We thus need to keep track
  of the "reserved" status of the entry block, and show that it doesn't change 
  when compiling the body. 

  We characterize this property of "increasing state" as follows.  *) 


(** The comparison [is <> nil] allows the status of a block to change from "reserved" 
(i.e. [is = []]) to "filled in" (i.e. [is <> []]). 
*)

Inductive cstate_incr : cstate -> cstate -> Prop :=
  cstate_incr_intro : forall ls ls' ids ids' g g',
    (forall l, In l ls -> In l ls') ->
    (forall l is, In l ls -> is <> nil ->
      ListCFG.lookup g  l = Some is -> ListCFG.lookup g' l = Some is) ->
    cstate_incr (ls, ids, g) (ls', ids', g').

Instance cstate_incr_trans : Transitive cstate_incr.
Proof.
  red. inversion 1. inversion 1. constructor; intuition.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ----------------------------------------------------------------- *)
(** *** Strong increasing state *)

(** The strong version says that the blocks in [ls] remain unchanged -- this means 
that their "reserved status" is unaffected. 
*)

Inductive cstate_incr_strong : cstate -> cstate -> Prop :=
  cstate_incr_strong_intro : forall ls ls' ids ids' g g',
    (forall l, In l ls -> In l ls') ->
    (forall l, In l ls -> ListCFG.lookup g l = ListCFG.lookup g' l) ->
    cstate_incr_strong (ls, ids, g) (ls', ids', g').

Instance cstate_incr_strong_refl : Reflexive cstate_incr_strong.
Proof.
  red. intro cs. destruct cs as [[? ?] ?]. constructor; auto.
Qed.

Instance cstate_incr_strong_trans : Transitive cstate_incr_strong.
Proof.
  red. inversion 1. inversion 1. subst. constructor. 
  auto. intros. transitivity (ListCFG.lookup g' l); eauto.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Monotonicity of Compiler State *)

(** When we add instructions to a block, the state goes from "reserved" to
filled in. *)

Lemma add_insns_incr : forall l is g ls ids cs',
  ListCFG.lookup g l = Some [] ->
  add_insns l is (ls, ids, g) = (cs', tt) ->
  cstate_incr (ls, ids, g) cs'.
Proof.
  destruct cs' as [[? ?] ?]. intros.
  constructor. inversion H0; intuition.
  intros. inversion H0; subst. rewrite ListCFG.update_neq. auto.
  contradict H2. subst l. rewrite H3 in H. injection H; auto.
Qed.


(** Lifting the FRESH monad into the CMD monad will create a computation that
never adds blocks, so its state increases "strongly". *)

Lemma FRESH_incr_strong : 
  forall (A:Type) (m:FRESH A) (r:A) cs cs' ,
  liftF m cs = (cs', r) ->
  cstate_incr_strong cs cs'.
Proof.
  destruct cs as [[? ?] ?], cs' as [[? ?] ?].
  inversion 1.
  destruct (m l0). inversion H1; subst; clear H1.
  constructor; auto; intros. 
Qed.

(**  ------------------------------------------------------------------------- *)
(* ----------------------------------------------------------------- *)
(** *** Filling in reserved blocks *)
(** If we create a fresh label (and thereby reserve a block) and then do some
compilation that doesn't fill in any reserved blocks, we can then add
instructions to the reserved block.  The end-to-end behavior of this sequence
does not change the status of blocks reserved earlier, so the whole thing
increases "strongly". *)

Lemma fresh_add_incr_strong :
  forall l is cs1 cs2 cs3 cs4,
  fresh_lbl cs1 = (cs2, l) ->
  cstate_incr_strong cs2 cs3 ->
  add_insns l is cs3 = (cs4, tt) ->
  cstate_incr_strong cs1 cs4.
Proof.
  intros until cs4. intros Hfresh Hincr Hadd.
  destruct cs1 as [[? ?] ?], cs2 as [[? ?] ?],
           cs3 as [[? ?] ?], cs4 as [[? ?] ?].
  inversion Hadd; inversion Hfresh; inversion Hincr; subst.

  constructor; intros. apply H8. right; auto.
  assert (Lbl.fresh l0 <> l).
    contradict H. rewrite <- H. apply Lbl.fresh_not_in.
  rewrite ListCFG.update_neq; auto. 
  rewrite <- H13.
  rewrite ListCFG.update_neq; auto.
  right. assumption.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ----------------------------------------------------------------- *)
(** *** The command compiler *)

(** The command compiler doesn't touch reserved blocks, so we can prove that it
affects the state under the stronger monotonicity requirements.
 *)

Lemma comp_com_incr_strong: forall c cst cst' e r,
  comp_com c r cst = (cst', e) -> cstate_incr_strong cst cst'.
Proof.
  induction c; intros cst cst' e r Htr; simpl in Htr; exploit_compile.

  - (* Case "CSkip".*)
    reflexivity. 

  - (* Case "CAss". *) 
  eapply fresh_add_incr_strong; eauto.
  eapply FRESH_incr_strong; eauto. 

  - (* Case "CSeq". *)
  eapply transitivity.
  eapply IHc2; eauto.  eapply IHc1; eauto.

  -  (* Case "CIf". *)
  eapply transitivity. eapply IHc1; eauto.
  eapply transitivity. eapply IHc2; eauto.
  eapply fresh_add_incr_strong; eauto. 
  eapply FRESH_incr_strong; eauto.

  - (* Case "CWhile". *)
  eapply fresh_add_incr_strong.
  eauto. eapply transitivity. eapply IHc; eauto.
  eapply FRESH_incr_strong; eauto. eauto.
Qed.
  
(**  ------------------------------------------------------------------------- *)
(* ----------------------------------------------------------------- *)
(** *** Weakening  *)

(** Of course, the "strong" monotonicity property implies regular
monotonicity. *)

Lemma cstate_incr_weaken : forall cst cst',
  cstate_incr_strong cst cst' ->
  cstate_incr cst cst'.
Proof.
  inversion 1. constructor. auto. intros. rewrite <- H1; auto.
Qed.

(** And so the whole command compiler is also monotonic according to the
[cstate_incr] *)

Lemma comp_com_incr: forall c cst cst' e r,
  comp_com c r cst = (cst', e) -> cstate_incr cst cst'.
Proof.
  intros. apply cstate_incr_weaken.
  eapply comp_com_incr_strong; eauto.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ================================================================= *)
(** ** Relating Initial Compilation *)

(** Finally, we can relate the initial state of the CFG machine obtained by 
compiling the Imp command.  The key lemma is: *)

Lemma match_init : forall c le lr csti cst x g' e,
  comp_com c lr csti = (cst, le) ->
  cstate_incr cst (x, g') ->
  match_config c (e, g', le, lr).
Proof.
  induction c; intros le lr csti cst x g' e Hcomp Hincr; simpl in Hcomp; exploit_compile.
  
  - (* Case "CSkip". *)
  apply MC_Skip.

  - (* Case "CAss". *)
    simpl in Heq. inversion Heq; subst; clear Heq.
    simpl in Heq0.
    destruct (comp_store a i lr ids1) eqn:Hc'.
    inversion Heq0; subst; clear Heq0.
    simpl in Heq1.
    inversion Heq1; subst; clear Heq1.

    eapply MC_Ass, cfg_insns_at.
    inversion Hincr. subst. 
    apply H5. left; auto.
    apply comp_store_not_nil. rewrite ListCFG.update_eq; auto. 
    f_equal. rewrite surjective_pairing in Hc' at 1. 
    inversion Hc'. reflexivity.

  - (* Case "CSeq". *)
    eapply MC_Seq. eapply IHc1; eauto. eapply IHc2; eauto.
    eapply transitivity; eauto. eapply comp_com_incr; eauto.

  - (* Case "CIf". *)
    eapply MC_If.

    + eapply IHc1; eauto.
      eapply transitivity. eapply comp_com_incr; eauto.
      eapply transitivity; eauto. eapply cstate_incr_weaken. 
      eapply fresh_add_incr_strong; eauto.
      eapply FRESH_incr_strong; eauto.

    + eapply IHc2; eauto.
      eapply transitivity; eauto. eapply cstate_incr_weaken.
      eapply fresh_add_incr_strong; eauto.
      eapply FRESH_incr_strong; eauto.

    + inversion Heq1. subst. clear Heq1.
      simpl in Heq2.
      exploit_compile.
      inversion Heq3. subst. clear Heq3.
      eapply cfg_insns_at.
      inversion Hincr. subst.
      apply H5. left; auto.
      apply comp_cond_not_nil.
      rewrite ListCFG.update_eq; auto. 
      f_equal.
      rewrite surjective_pairing in Heq1 at 1. 
      inversion Heq1. reflexivity.
      
  - (* Case "CWhile". *)
    eapply MC_While with (cs:=ids2).

    + simpl in Heq. inversion Heq; subst. clear Heq.
    
      eapply IHc. eauto.
      apply comp_com_incr_strong in Heq0.
      apply FRESH_incr_strong in Heq1.
      eapply transitivity; eauto.
      eapply transitivity; eauto.
      eapply cstate_incr_weaken; eauto.
      apply add_insns_incr in Heq2; eauto.

      inversion Heq1. subst. rewrite <- H6.
      inversion Heq0. subst. rewrite <- H8. 
      rewrite ListCFG.update_eq; auto.
      left. auto.
      inversion Heq0. subst. apply H2. left. auto.
      
    + inversion Heq.  subst.

      apply cfg_insns_at.
      inversion Hincr. subst. 
      apply H5.

      apply comp_com_incr_strong in Heq0.
      apply FRESH_incr_strong in Heq1.      
      inversion Heq0. subst.
      inversion Heq2. subst.
      inversion Heq1. subst.
      apply H3. apply H2. left. reflexivity.
      
      apply comp_cond_not_nil.
      
      inversion Heq2. subst. rewrite ListCFG.update_eq; auto.
      f_equal. rewrite surjective_pairing in Heq1 at 1.
      inversion Heq1. subst. unfold strun.
      destruct (comp_cond b r0 lr ids2). reflexivity.
Qed.


Lemma match_config_initial : forall g le lr c m,
  (g, le, lr) = compile c ->
  match_states g lr (c, m) (init_state g m).
Proof.
  intros. unfold compile, comp_prog in H. simpl in H. exploit_compile.
  econstructor; simpl; eauto.

  eapply match_init. eauto. eapply cstate_incr_weaken. 
  eapply cstate_incr_strong_refl.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Simulation Diagram  *)

(** Recall the simulation diagram from Xavier's lectures. *)

Section SIMULATION_DIAGRAM.

Variable state1: Type.	                          (* source states *)
Variable step1: state1 -> state1 -> Prop.         (* source step relation *)

Variable state2: Type.	                          (* target states *)
Variable step2: state2 -> state2 -> Prop.         (* target step relation *)

Variable match_states: state1 -> state2 -> Prop.  (* the invariant *)

Variable measure: state1 -> nat.                  (* for stuttering *)

Hypothesis simulation:
  forall S1 S1' S2,
  step1 S1 S1' -> match_states S1 S2 ->
  exists S2',
    (plus step2 S2 S2' \/ 
     star step2 S2 S2' /\ measure S1' < measure S1) /\
    match_states S1' S2'.

Lemma simulation_star:
  forall S1 S1', star step1 S1 S1' ->
  forall S2, match_states S1 S2 ->
  exists S2', star step2 S2 S2' /\ match_states S1' S2'.
Proof.
  induction 1; intros.

  - (* Case "zero transition". *)
  exists S2; split. apply star_refl. auto.

  - (* Case "one or more transitions". *)
  destruct (simulation _ _ _ H H1) as [S2' [P Q]].
  destruct (IHstar _ Q) as [S2'' [U V]].
  exists S2''; split. 
  eapply star_trans; eauto. destruct P. 
  apply plus_star; auto. destruct H2; auto.
  auto.
Qed.

Lemma simulation_infseq_productive:
  forall N S1 S2,
  measure S1 < N ->
  infseq step1 S1 ->
  match_states S1 S2 ->
  exists S1', exists S2',
      plus step2 S2 S2'
   /\ infseq step1 S1'
   /\ match_states S1' S2'.
Proof.
  induction N; intros. 
  - (* Case "N = 0". *)
  omega. 
  - (* Case "N > 0". *)
  inversion H0; clear H0; subst.
  destruct (simulation _ _ _ H2 H1) as [S2' [P Q]].
  destruct P.
  + (* SCase "one or several transitions". *)
  exists b; exists S2'; auto.
  + (* SCase "zero, one or several transitions". *)
  destruct H0. inversion H0; clear H0; subst.
    * (* SSCase "zero transitions". *)
    eapply IHN; eauto. omega.
    * (* SSCase "one or several transitions". *)
    exists b; exists S2'; split. eapply plus_left; eauto. auto.
Qed.

Lemma simulation_infseq:
  forall S1 S2,
  infseq step1 S1 ->
  match_states S1 S2 ->
  infseq step2 S2.
Proof.
  intros. 
  apply infseq_coinduction_principle_2 with
    (X := fun S2 => exists S1, infseq step1 S1 /\ match_states S1 S2).
  intros. destruct H1 as [S [A B]]. 
  destruct (simulation_infseq_productive (measure S + 1) S a) 
  as [S1' [S2' [P [Q R]]]].
  omega. auto. auto.
  exists S2'; split. auto. exists S1'; auto. 
  exists S1; auto.
Qed.

End SIMULATION_DIAGRAM.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Vminus Instance  *)

(** We can complete the same simulation diagram for this Imp to Vminus
compiler. *)

Definition vminus_terminates (g:ListCFG.t) (m m':mem) : Prop :=
  exists x st',
    insns_at_pc g st'.(st_pc) [(x, cmd_tmn tmn_ret)] /\
    st'.(st_mem) = m' /\
    star (step g) (init_state g m) st'.
  
Definition vminus_diverges (g:ListCFG.t) (m:mem) : Prop :=
  infseq (step g) (init_state g m).

Definition imp_terminates (c: com) (m m':mem) : Prop :=
  star Imp.step (c, m) (SKIP, m').

Definition imp_diverges (c: com) (mem: mem) : Prop :=
  infseq Imp.step (c, mem).

Lemma match_config_ret : forall g le lr c,
  (g, le, lr) = compile c ->
  exists x, insns_at_pc g (block_entry lr) [(x, cmd_tmn tmn_ret)].
Proof.
  intros. unfold compile, comp_prog in H. simpl in H. exploit_compile.
  
  eexists. eapply cfg_insns_at. apply comp_com_incr_strong in Heq1.
  inversion Heq1; subst. rewrite <- H6. rewrite ListCFG.update_eq; auto.
  left. reflexivity.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Correct When Terminating  *)

Theorem compile_program_correct_terminating:
  forall c m m' g le lr,
  (g, le, lr) = compile c ->
  imp_terminates c m m' ->
  vminus_terminates g m m'.
Proof.
  intros. unfold imp_terminates in H.
  assert (exists machconf2, 
           star (step g) (init_state g m) machconf2
           /\ match_states g lr (SKIP, m') machconf2).
  eapply simulation_star; eauto. eapply simulation_step.
  eapply match_config_initial; eauto.
  destruct H1 as [machconf2 [STAR MS]]. 
  inversion MS; subst.
  eelim match_config_ret. intros.
  red. exists x, machconf2. split. rewrite H4. eauto. eauto. 
  inversion H3; subst. eauto.
Qed.

(**  ------------------------------------------------------------------------- *)
(* ################################################################# *)
(** * Correct When Diverging  *)

Theorem compile_program_correct_diverging:
  forall c m g le lr,
  (g, le, lr) = compile c ->
  imp_diverges c m ->
  vminus_diverges g m.
Proof.
  intros; red; intros. 
  eapply simulation_infseq with (match_states := match_states g lr); eauto.
  eapply simulation_step. eapply match_config_initial; eauto.
Qed.

