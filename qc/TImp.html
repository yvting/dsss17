<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>TImp: Case Study: a Typed Imperative Language</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/plf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
<ul id='menu'>
   <a href='index.html'><li class='section_name'>Property-Based Testing </li></a>
   <a href='toc.html'><li>Table of Contents</li></a>
   <a href='coqindex.html'><li>Index</li></a>
   <a href='deps.html'><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">TImp<span class="subtitle">Case Study: a Typed Imperative Language</span></h1>


<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;BCP:&nbsp;Some&nbsp;random&nbsp;things&nbsp;to&nbsp;do&nbsp;soon:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;80-column-ify<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Turn&nbsp;exercises&nbsp;into&nbsp;SF-style&nbsp;using&nbsp;EX&nbsp;tags<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;Start&nbsp;producing&nbsp;a&nbsp;TERSE&nbsp;version&nbsp;that&nbsp;we&nbsp;can&nbsp;use&nbsp;for&nbsp;lecturing<br/>
*)</span><br/>

<br/>

<br/>
</div>

<div class="doc">
Having seen a basic overview of QuickChick in the previous
    chapter, we can now dive into a more realistic case study: a typed
    variant of Imp, the simple imperative language introduced in
    <i>Logical Foundations</i>.  The original Imp variant presented in the
    first volume of Software Foundations syntactically separates
    boolean and arithmetic expressions: <span class="inlinecode"><span class="id" type="var">bexp</span></span> ranges over boolean
    expressions, while <span class="inlinecode"><span class="id" type="var">aexp</span></span> ranges over arithmetic ones.  Moreover,
    variables are only allowed in <span class="inlinecode"><span class="id" type="var">aexp</span></span> and only take arithmetic
    values.

<div class="paragraph"> </div>

    In typed Imp (TImp) we collapse the expression syntax and allow
    variables to range over both numbers and booleans. With the
    unified syntax, we introduce the notion of well-typed Imp
    expressions and programs: where every variable only ranges over
    values of a single type throughout the whole program.  We then
    give an operational semantics to TImp in the form of a partial
    evaluation function; partial, since in the unified syntax one
    could attempt to write expressions such as <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" type="var">True</span></span>.

<div class="paragraph"> </div>

    A common mantra in functional programming is "well-typed programs
    cannot go wrong"; TImp is no exception to that rule. The soundness
    property for TImp will state that evaluating well-typed
    expressions and programs always succeeds. This is another example
    of a <i>conditional</i> property. As we saw in the previous chapter,
    testing such properties requires custom generators.  In this
    chapter, we will show how to scale the techniques for writing
    generators to more realistic generators for well-typed expressions
    and programs. In addition, we will also demonstrate the notion and
    necessity of custom shrinkers preserving invariants, a problem
    dual to that of custom generators. 
<div class="paragraph"> </div>

<a name="lab72"></a><h1 class="section">Atoms, Types and Contexts</h1>

<div class="paragraph"> </div>

<a name="lab73"></a><h2 class="section">Atoms</h2>

</div>
<div class="code code-space">

<br/>
<span class="comment">(*&nbsp;Leo:&nbsp;How&nbsp;can&nbsp;we&nbsp;cite&nbsp;things&nbsp;in&nbsp;SF-style?&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;BCP:&nbsp;Do&nbsp;you&nbsp;mean&nbsp;bibliographic&nbsp;citations?&nbsp;&nbsp;Or&nbsp;URLs?&nbsp;&nbsp;Urls&nbsp;are<br/>
&nbsp;&nbsp;&nbsp;<a href="http://likethis"><span class="inlineref">http://likethis</span></a>&nbsp;and&nbsp;bib&nbsp;stuff&nbsp;is&nbsp;\Bib{Like&nbsp;This,&nbsp;2017},&nbsp;plus&nbsp;add<br/>
&nbsp;&nbsp;&nbsp;it&nbsp;to&nbsp;Bib.v&nbsp;(following&nbsp;the&nbsp;style&nbsp;of&nbsp;SF)&nbsp;and&nbsp;make&nbsp;sure&nbsp;Bib.v&nbsp;is&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;the&nbsp;Makefile.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Leo:&nbsp;Decide:&nbsp;atoms,&nbsp;<span class="inlinecode"><span class="id" type="var">Atom</span></span>s&nbsp;or&nbsp;<span class="inlinecode"><span class="id" type="var">Atoms</span></span>?&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;BCP:&nbsp;I&nbsp;think&nbsp;switching&nbsp;back&nbsp;and&nbsp;forth&nbsp;between&nbsp;the&nbsp;first&nbsp;and&nbsp;second&nbsp;is&nbsp;fine.&nbsp;*)</span><br/>
</div>

<div class="doc">
For the type of identifiers of TImp we are going to borrow (a simplified
    version of) <span class="inlinecode"><span class="id" type="var">Atom</span></span> from Penn's Metatheory library. <span class="inlinecode"><span class="id" type="var">Atom</span></span> is essentially a
    wrapper around <span class="inlinecode"><span class="id" type="var">nat</span></span> which supports decidable equality and <span class="inlinecode"><span class="id" type="tactic">fresh</span></span>: given
    any finite set of atoms, one can produce one that is distinct from all of
    the atoms in the set. 
<div class="paragraph"> </div>

 We declare that atoms are an instance of Coq's <span class="inlinecode"><span class="id" type="var">UsualDecidableType</span></span>.
    That is, the standard coq equality <span class="inlinecode">(=)</span> is decidable for them. 
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Type</span> <span class="id" type="var">ATOM</span> &lt;: <span class="id" type="var">UsualDecidableType</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">t</span> : <span class="id" type="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">eq_dec</span> : ∀ (<span class="id" type="var">x</span> <span class="id" type="var">y</span>:<span class="id" type="var">t</span>), {<span class="id" type="var">x</span> = <span class="id" type="var">y</span>} + {<span class="id" type="var">x</span> ≠ <span class="id" type="var">y</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="tactic">fresh</span> : <span class="id" type="var">list</span> <span class="id" type="var">t</span> → <span class="id" type="var">t</span>.<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">nat_of</span>: <span class="id" type="var">t</span> → <span class="id" type="var">nat</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">ATOM</span>.<br/>

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">Atom</span> : <span class="id" type="var">ATOM</span>.<br/>
</div>

<div class="doc">
Internally, an <span class="inlinecode"><span class="id" type="var">Atom</span></span> is just a natural number... 
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="var">t</span> := <span class="id" type="var">nat</span>.<br/>
</div>

<div class="doc">
...which means decidable equality comes for free from the standard library: 
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="var">eq_dec</span> := <span class="id" type="var">eq_nat_dec</span>.<br/>
</div>

<div class="doc">
To compute a fresh natural number given a list of natural numbers,
    we can just produce the number that is 1 larger than the maximum
    element: 
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">max_elt</span> (<span class="id" type="var">al</span>:<span class="id" type="var">list</span> <span class="id" type="var">t</span>) : <span class="id" type="var">t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">al</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">n'</span>::<span class="id" type="var">al'</span> ⇒ <span class="id" type="var">max</span> <span class="id" type="var">n'</span> (<span class="id" type="var">max_elt</span> <span class="id" type="var">al'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="tactic">fresh</span> (<span class="id" type="var">al</span>:<span class="id" type="var">list</span> <span class="id" type="var">t</span>) : <span class="id" type="var">t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">S</span> (<span class="id" type="var">max_elt</span> <span class="id" type="var">al</span>).<br/>
</div>

<div class="doc">
We also need a way of printing atoms. To support that, we include a 
    <span class="inlinecode"><span class="id" type="var">nat_of</span></span> function that exposes the internal natural number. 
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="var">nat_of</span> (<span class="id" type="var">a</span> : <span class="id" type="var">nat</span>) := <span class="id" type="var">a</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Atom</span>.<br/>
</div>

<div class="doc">
We can take advantage of the <span class="inlinecode"><span class="id" type="var">nat_of</span></span> function of <span class="inlinecode"><span class="id" type="var">Atom</span></span>s, as well
    as the <span class="inlinecode"><span class="id" type="keyword">Show</span></span> instance of <span class="inlinecode"><span class="id" type="var">nat</span></span> to print <span class="inlinecode"><span class="id" type="var">Atom</span></span>s. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">show_atom</span> : <span class="id" type="keyword">Show</span> <span class="id" type="var">Atom.t</span> :=<br/>
&nbsp;&nbsp;{| <span class="id" type="var">show</span> <span class="id" type="var">x</span> := <span class="id" type="var">show</span> (<span class="id" type="var">Atom.nat_of</span> <span class="id" type="var">x</span>) |}.<br/>
</div>

<div class="doc">
To generate identifiers for TImp, we will use a recursive functions 
    that generates <span class="inlinecode"><span class="id" type="var">n</span></span> fresh <span class="inlinecode"><span class="id" type="var">Atom</span></span>s starting from the empty list. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">get_fresh_atoms</span> <span class="id" type="var">n</span> <span class="id" type="var">l</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">l</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒ <span class="id" type="var">get_fresh_atoms</span> <span class="id" type="var">n'</span> ((<span class="id" type="var">Atom.fresh</span> <span class="id" type="var">l</span>) :: <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab74"></a><h4 class="section">Exercise: 2 stars (genAtom)</h4>
 Write an instance for <span class="inlinecode"><span class="id" type="var">Gen</span></span> for <span class="inlinecode"><span class="id" type="var">Atom.t</span></span>, using the <span class="inlinecode"><span class="id" type="var">elements</span></span> 
    combinator and <span class="inlinecode"><span class="id" type="var">get_fresh_atoms</span></span>.  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab75"></a><h2 class="section">Types</h2>

<div class="paragraph"> </div>

 To continue, here is the type of types in TImp, <span class="inlinecode"><span class="id" type="var">ty</span></span>: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">ty</span> := <span class="id" type="var">TBool</span> | <span class="id" type="var">TNat</span>.<br/>
</div>

<div class="doc">
TImp has two types of expressions: booleans and natural numbers. 
<div class="paragraph"> </div>

 As with all user-defined datatypes, in order to use <span class="inlinecode"><span class="id" type="var">ty</span></span> in testing
    we will need <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span>, <span class="inlinecode"><span class="id" type="keyword">Show</span></span> and an equality <span class="inlinecode"><span class="id" type="var">Dec</span></span> instance. 
<div class="paragraph"> </div>

 In QC.v, we saw how one can go about writing such generators by hand.
    However, that process can largely be automated, especially for 
    simple inductive types (like <span class="inlinecode"><span class="id" type="var">ty</span></span>, <span class="inlinecode"><span class="id" type="var">nat</span></span>, <span class="inlinecode"><span class="id" type="var">list</span></span>, <span class="inlinecode"><span class="id" type="var">tree</span></span>, etc.). 
    QuickChick provides a top-level vernacular command to derive 
    such instances. 
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Derive</span> (<span class="id" type="var">Arbitrary</span>, <span class="id" type="keyword">Show</span>) <span class="id" type="keyword">for</span> <span class="id" type="var">ty</span>.<br/>
<span class="comment">(*&nbsp;==&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;genSty&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;shrty&nbsp;is&nbsp;defined<br/>
&nbsp;&nbsp;&nbsp;&nbsp;showty&nbsp;is&nbsp;defined<br/>
*)</span><br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">genSty</span>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;genSty&nbsp;:&nbsp;GenSized&nbsp;ty&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">shrty</span>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;shrty&nbsp;&nbsp;:&nbsp;Shrink&nbsp;ty&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">showty</span>.<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;showty&nbsp;:&nbsp;Show&nbsp;ty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
</div>

<div class="doc">
The decidable equality instances are not yet derived fully automatically.
    However, the boilerplate for it is largely straightforward. As we saw in 
    the previous chapters, <span class="inlinecode"><span class="id" type="var">Dec</span></span> is a typeclass wrapper around ssreflect's 
    <span class="inlinecode"><span class="id" type="var">decidable</span></span>. We just unfold that and use the <span class="inlinecode"><span class="id" type="var">decide</span></span> <span class="inlinecode"><span class="id" type="var">equality</span></span> <span class="inlinecode"><span class="id" type="var">tactic</span></span>.

<div class="paragraph"> </div>

  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">eq_dec_ty</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">ty</span>) : <span class="id" type="var">Dec</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>) := {}.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>; <span class="id" type="var">decide</span> <span class="id" type="var">equality</span>. <span class="id" type="keyword">Defined</span>.<br/>
</div>

<div class="doc">
<a name="lab76"></a><h2 class="section">List Map with Decidable Equality</h2>

<div class="paragraph"> </div>

 To encode typing environments and, later on, states, we will need 
    maps from atoms to values. The function-based representation in base 
    Imp is not suited for testing: we will need to be able to access the 
    domain of the map, fold over it and test for equality; all operations
    not supported by (Coq) functions. Therefore, we introduce a small 
    list-based map that takes usual decidable types (like <span class="inlinecode"><span class="id" type="var">Atom</span></span>) as input.

<div class="paragraph"> </div>

    The operations we need are:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" type="var">empty</span></span> : To create the empty map.

</li>
<li> <span class="inlinecode"><span class="id" type="var">get</span></span>   : To look up the binding of an element, if any.

</li>
<li> <span class="inlinecode"><span class="id" type="tactic">set</span></span>   : To update the binding of an element.

</li>
<li> <span class="inlinecode"><span class="id" type="var">dom</span></span>   : To get the list of keys in the map.

</li>
</ul>
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="keyword">Type</span> <span class="id" type="var">Map</span> (<span class="id" type="var">K</span>:<span class="id" type="var">UsualDecidableType</span>).<br/>

<br/>
&nbsp;<span class="id" type="keyword">Section</span> <span class="id" type="var">withv</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Variable</span> <span class="id" type="var">V</span> : <span class="id" type="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">t</span> : <span class="id" type="keyword">Type</span> → <span class="id" type="keyword">Type</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">empty</span> : <span class="id" type="var">t</span> <span class="id" type="var">V</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">get</span> : <span class="id" type="var">t</span> <span class="id" type="var">V</span> → <span class="id" type="var">K.t</span> → <span class="id" type="var">option</span> <span class="id" type="var">V</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="tactic">set</span> : <span class="id" type="var">t</span> <span class="id" type="var">V</span> → <span class="id" type="var">K.t</span> → <span class="id" type="var">V</span> → <span class="id" type="var">t</span> <span class="id" type="var">V</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Parameter</span> <span class="id" type="var">dom</span> : <span class="id" type="var">t</span> <span class="id" type="var">V</span> → <span class="id" type="var">list</span> <span class="id" type="var">K.t</span>.<br/>
&nbsp;<span class="id" type="keyword">End</span> <span class="id" type="var">withv</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">Map</span>.<br/>
</div>

<div class="doc">
The implementation of the map is a simple association list. 
    If a list contains multiple tuples with the same key, then 
    the binding of the key in the map is the one that appears firt 
    in the list; that is, bindings can be shadowed.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">ListMap</span> (<span class="id" type="var">K</span>:<span class="id" type="var">UsualDecidableType</span>) &lt;: <span class="id" type="var">Map</span> <span class="id" type="var">K</span>.<br/>

<br/>
&nbsp;<span class="id" type="keyword">Section</span> <span class="id" type="var">withv</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Context</span> {<span class="id" type="var">V</span> : <span class="id" type="keyword">Type</span>}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="var">t</span> := <span class="id" type="var">list</span> (<span class="id" type="var">K.t</span> * <span class="id" type="var">V</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="var">empty</span> : <span class="id" type="var">t</span> := [].<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">get</span> <span class="id" type="var">m</span> <span class="id" type="var">k</span> : <span class="id" type="var">option</span> <span class="id" type="var">V</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">k'</span>, <span class="id" type="var">v</span>) :: <span class="id" type="var">m'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">K.eq_dec</span> <span class="id" type="var">k</span> <span class="id" type="var">k'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Some</span> <span class="id" type="var">v</span> <span class="id" type="keyword">else</span> <span class="id" type="var">get</span> <span class="id" type="var">m'</span> <span class="id" type="var">k</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="tactic">set</span> (<span class="id" type="var">m</span>:<span class="id" type="var">t</span>) (<span class="id" type="var">k</span>:<span class="id" type="var">K.t</span>) (<span class="id" type="var">v</span>:<span class="id" type="var">V</span>) : <span class="id" type="var">t</span> := (<span class="id" type="var">k</span>, <span class="id" type="var">v</span>) :: <span class="id" type="var">m</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">dom</span> (<span class="id" type="var">m</span>:<span class="id" type="var">t</span>) : <span class="id" type="var">list</span> <span class="id" type="var">K.t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [] ⇒ []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" type="var">k'</span>, <span class="id" type="var">v</span>) :: <span class="id" type="var">m'</span> ⇒ <span class="id" type="var">k'</span> :: <span class="id" type="var">dom</span> <span class="id" type="var">m'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
&nbsp;<span class="id" type="keyword">End</span> <span class="id" type="var">withv</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">ListMap</span>.<br/>
</div>

<div class="doc">
We instantiate this functor with <span class="inlinecode"><span class="id" type="var">Atom</span></span>, yielding <span class="inlinecode"><span class="id" type="var">AtomMap</span></span> our 
    map with <span class="inlinecode"><span class="id" type="var">Atom</span></span> as the key type. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">AtomMap</span> := <span class="id" type="var">ListMap</span> (<span class="id" type="var">Atom</span>).<br/>
</div>

<div class="doc">
We introduce a simple inductive proposition, <span class="inlinecode"><span class="id" type="var">bound_to</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span>, that 
    holds precisely when the binding of some <span class="inlinecode"><span class="id" type="var">Atom</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> is equal to <span class="inlinecode"><span class="id" type="var">a</span></span> in 
    <span class="inlinecode"><span class="id" type="var">m</span></span> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">bound_to</span> {<span class="id" type="var">A</span>} : @<span class="id" type="var">AtomMap.t</span> <span class="id" type="var">A</span> → <span class="id" type="var">Atom.t</span> → <span class="id" type="var">A</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="keyword">Bind</span> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">m</span> <span class="id" type="var">a</span>, <span class="id" type="var">AtomMap.get</span> <span class="id" type="var">m</span> <span class="id" type="var">x</span> = <span class="id" type="var">Some</span> <span class="id" type="var">a</span> → <span class="id" type="var">bound_to</span> <span class="id" type="var">m</span> <span class="id" type="var">x</span> <span class="id" type="var">a</span>.<br/>
</div>

<div class="doc">
We can now decide whether <span class="inlinecode"><span class="id" type="var">bound_to</span></span> <span class="inlinecode"><span class="id" type="var">m</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> holds for a given 
    arrangement of <span class="inlinecode"><span class="id" type="var">m</span></span>, <span class="inlinecode"><span class="id" type="var">x</span></span> and <span class="inlinecode"><span class="id" type="var">a</span></span>. In a first reading, you can
    skip the next few paragraphs (until the start of the <span class="inlinecode"><span class="id" type="var">context</span></span>
    subsection) that deal with partially automating 
    the proofs for such instances. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">dec_bound_to</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> (<span class="id" type="var">T</span> : <span class="id" type="var">A</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<span class="id" type="var">D</span> : ∀ (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">A</span>), <span class="id" type="var">Dec</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>)}<br/>
&nbsp;&nbsp;: <span class="id" type="var">Dec</span> (<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T</span>) := {}.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">AtomMap.get</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span>) <span class="id" type="var">eqn</span>:<span class="id" type="var">Get</span>.<br/>
</div>

<div class="doc">
After unfolding <span class="inlinecode"><span class="id" type="var">decidable</span></span> and destructing <span class="inlinecode"><span class="id" type="var">AtomMap.get</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>, we are
    left with two subgoals. In the first, we know that <span class="inlinecode"><span class="id" type="var">AtomMap.get</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span>
    <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span> and effectively want to decide whether <span class="inlinecode"><span class="id" type="var">AtomMap.get</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">Some</span></span>
    <span class="inlinecode"><span class="id" type="var">T</span></span> or not. Which means we need to decide whether <span class="inlinecode"><span class="id" type="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">T</span></span>. Thankfully,
    we can decide that using our hypothesis <span class="inlinecode"><span class="id" type="var">D</span></span>. 
  
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> (<span class="id" type="var">D</span> <span class="id" type="var">a</span> <span class="id" type="var">T</span>) <span class="id" type="keyword">as</span> [[<span class="id" type="var">Eq</span> | <span class="id" type="var">NEq</span>]]; <span class="id" type="tactic">subst</span>.<br/>
</div>

<div class="doc">
At this point, the first goal can be immediately decided positevely
    using constructor. 
  
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">left</span>. <span class="id" type="var">constructor</span>. <span class="id" type="tactic">auto</span>.<br/>
</div>

<div class="doc">
In the second subgoal, we can show that <span class="inlinecode"><span class="id" type="var">bound_to</span></span> doesn't hold. 
</div>
<div class="code code-tight">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" type="var">right</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">Contra</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Contra</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Contra</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">congruence</span>.<br/>
</div>

<div class="doc">
Both of these tactic patterns are very common in non-trival <span class="inlinecode"><span class="id" type="var">Dec</span></span> 
    instances. For that reason, we automate them a bit using LTac.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
A lot of the time, we can immediately decide a property positevly 
    using constructor applications. That is captured in <span class="inlinecode"><span class="id" type="var">solve_left</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_left</span>  := <span class="id" type="tactic">try</span> <span class="id" type="var">solve</span> [<span class="id" type="var">left</span>; <span class="id" type="var">econstructor</span>; <span class="id" type="tactic">eauto</span>].<br/>
</div>

<div class="doc">
Much of the time, we can also immediately decide that a property 
    doesn't hold by assuming it, doing inversion and using <span class="inlinecode"><span class="id" type="tactic">congruence</span></span>.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_right</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">Contra</span> := <span class="id" type="tactic">fresh</span> "Contra" <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve</span> [<span class="id" type="var">right</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">Contra</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Contra</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Contra</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eauto</span>; <span class="id" type="tactic">congruence</span>].<br/>
</div>

<div class="doc">
We group both in a single tactic, which does nothing at all if 
    it fails to solve a goal, thanks to <span class="inlinecode"><span class="id" type="tactic">try</span></span> <span class="inlinecode"><span class="id" type="var">solve</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_sum</span> := <span class="id" type="var">solve_left</span>; <span class="id" type="var">solve_right</span>.<br/>
</div>

<div class="doc">
We can now prove the <span class="inlinecode"><span class="id" type="var">Dec</span></span> instance more concisely. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">dec_bound_to</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> (<span class="id" type="var">T</span> : <span class="id" type="var">A</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<span class="id" type="var">D</span> : ∀ (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">A</span>), <span class="id" type="var">Dec</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>)}<br/>
&nbsp;&nbsp;: <span class="id" type="var">Dec</span> (<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T</span>) := {}.<br/>
<div class="togglescript" id="proofcontrol1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')"><span class="show"></span></div>
<div class="proofscript" id="proof1" onclick="toggleDisplay('proof1');toggleDisplay('proofcontrol1')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">AtomMap.get</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span>) <span class="id" type="var">eqn</span>:<span class="id" type="var">Get</span>; <span class="id" type="var">solve_sum</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">D</span> <span class="id" type="var">a</span> <span class="id" type="var">T</span>) <span class="id" type="keyword">as</span> [[<span class="id" type="var">Eq</span> | <span class="id" type="var">NEq</span>]]; <span class="id" type="tactic">subst</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
<a name="lab77"></a><h2 class="section">Contexts</h2>

<div class="paragraph"> </div>

 Typing contexts in TImp are just maps from atoms to types. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">context</span> := @<span class="id" type="var">AtomMap.t</span> <span class="id" type="var">ty</span>.<br/>
</div>

<div class="doc">
Given a context <span class="inlinecode"><span class="id" type="var">Gamma</span></span> and a type <span class="inlinecode"><span class="id" type="var">T</span></span>, we can try to generate 
    a random <span class="inlinecode"><span class="id" type="var">Atom</span></span> whose binding in <span class="inlinecode"><span class="id" type="var">Gamma</span></span> is <span class="inlinecode"><span class="id" type="var">T</span></span>. 

<div class="paragraph"> </div>

    We filter out all of the elements in <span class="inlinecode"><span class="id" type="var">Gamma</span></span> whose type is
    equal to <span class="inlinecode"><span class="id" type="var">T</span></span> and then, for each <span class="inlinecode">(<span class="id" type="var">a</span>,<span class="id" type="var">T'</span>)</span> that remains we 
    return the binding <span class="inlinecode"><span class="id" type="var">a</span></span>. We use the <span class="inlinecode"><span class="id" type="var">oneof</span></span> combinator to 
    pick an generator from that list at random. 

<div class="paragraph"> </div>

    However, the filtered list might be empty; to facilitate
    that case, <span class="inlinecode"><span class="id" type="var">oneof</span></span> also takes a default generator, here <span class="inlinecode"><span class="id" type="var">ret</span></span> <span class="inlinecode"><span class="id" type="var">None</span></span>.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_typed_atom_from_context</span> (<span class="id" type="var">Gamma</span> : <span class="id" type="var">context</span>) (<span class="id" type="var">T</span> : <span class="id" type="var">ty</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">Atom.t</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">oneof</span> (<span class="id" type="var">ret</span> <span class="id" type="var">None</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> '(<span class="id" type="var">a</span>,<span class="id" type="var">T'</span>) ⇒ <span class="id" type="var">ret</span> (<span class="id" type="var">Some</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">List.filter</span> (<span class="id" type="keyword">fun</span> '(<span class="id" type="var">a</span>,<span class="id" type="var">T'</span>) ⇒ <span class="id" type="var">T</span> = <span class="id" type="var">T'</span>?) <span class="id" type="var">Gamma</span>)).<br/>
</div>

<div class="doc">
We also need to generate a typing context to begin with. Given 
    some natural number <span class="inlinecode"><span class="id" type="var">n</span></span> to serve as the size of the context, 
    we first create its domain, <span class="inlinecode"><span class="id" type="var">n</span></span> fresh atoms. 

<div class="paragraph"> </div>

    We then create <span class="inlinecode"><span class="id" type="var">n</span></span> arbitrary types with <span class="inlinecode"><span class="id" type="var">vectorOf</span></span>, using the 
    <span class="inlinecode"><span class="id" type="var">Gen</span></span> instance for <span class="inlinecode"><span class="id" type="var">ty</span></span> we derived earlier.

<div class="paragraph"> </div>

    Finally, we zip (<span class="inlinecode"><span class="id" type="var">List.combine</span></span>) the domain with the ranges and 
    fold over the resulting, inserting each binding into a map.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_context</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">G</span> <span class="id" type="var">context</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">domain</span> := <span class="id" type="var">get_fresh_atoms</span> <span class="id" type="var">n</span> [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="var">range</span> &lt;- <span class="id" type="var">vectorOf</span> <span class="id" type="var">n</span> <span class="id" type="var">arbitrary</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">List.fold_left</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> '(<span class="id" type="var">k</span>, <span class="id" type="var">v</span>) ⇒ <span class="id" type="var">AtomMap.set</span> <span class="id" type="var">m</span> <span class="id" type="var">k</span> <span class="id" type="var">v</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">List.combine</span> <span class="id" type="var">domain</span> <span class="id" type="var">range</span>) <span class="id" type="var">AtomMap.empty</span>).<br/>
</div>

<div class="doc">
<a name="lab78"></a><h1 class="section">Expressions</h1>

<div class="paragraph"> </div>

 We are now ready to introduce the syntax of expressions in TImp. 
    The original Imp had two distinct types of expressions: arithmetic
    and boolean expressions, while variables were only allowed to 
    range over natural numbers. In TImp, we extend variables to range 
    over boolean values as well, collapsing the expressions into a single 
    type <span class="inlinecode"><span class="id" type="var">exp</span></span>. 

<div class="paragraph"> </div>

 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">exp</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">EVar</span> : <span class="id" type="var">Atom.t</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ENum</span> : <span class="id" type="var">nat</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EPlus</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EMinus</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EMult</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ETrue</span> : <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EFalse</span> : <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EEq</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ELe</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ENot</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EAnd</span> : <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">exp</span>.<br/>
</div>

<div class="doc">
To be able to print expressions we can derive <span class="inlinecode"><span class="id" type="keyword">Show</span></span> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="keyword">Show</span> <span class="id" type="keyword">for</span> <span class="id" type="var">exp</span>.<br/>
</div>

<div class="doc">
If we tried to derive <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span> for expressions we would 
    encounter an error message: 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;==&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unable&nbsp;to&nbsp;satisfy&nbsp;the&nbsp;following&nbsp;constraints:&nbsp;<span class="inlinecode"><span class="id" type="var">Gen</span></span> <span class="inlinecode"><span class="id" type="var">Atom.t</span></span><br/>
*)</span><br/>
</div>

<div class="doc">
Indeed, we don't have an arbitrary instance for <span class="inlinecode"><span class="id" type="var">Atom.t</span></span>, only a function
    (<span class="inlinecode"><span class="id" type="var">gen_typed_atom_from_context</span></span>) that can (maybe) generate atoms given a
    context and a type.  
<div class="paragraph"> </div>

<a name="lab79"></a><h2 class="section">Typed Expressions</h2>

<div class="paragraph"> </div>

 The following inductive relation characterizes well-typed expressions
    of a particular type. It is rather unsurprising, using <span class="inlinecode"><span class="id" type="var">bound_to</span></span> to 
    access the typing context in the variable case 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;BCP:&nbsp;Maybe&nbsp;define&nbsp;a&nbsp;Notation&nbsp;for&nbsp;this&nbsp;to&nbsp;lighten&nbsp;the&nbsp;presentation?&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Leo:&nbsp;"&#x2208;"&nbsp;doesn't&nbsp;work.&nbsp;What&nbsp;symbol&nbsp;do&nbsp;we&nbsp;want?&nbsp;Ascii?&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Leo:&nbsp;No&nbsp;idea&nbsp;how&nbsp;to&nbsp;make&nbsp;this&nbsp;slide&nbsp;prettier...&nbsp;*)</span><br/>
<span class="id" type="keyword">Reserved Notation</span> "Gamma '||-' e ':-' T" (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 40).<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">has_type</span> : <span class="id" type="var">context</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">ty</span> → <span class="id" type="keyword">Prop</span> := <br/>
| <span class="id" type="var">Ty_Var</span> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">T</span> <span class="id" type="var">Gamma</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T</span> → <span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">EVar</span> <span class="id" type="var">x</span>) :- <span class="id" type="var">T</span><br/>
| <span class="id" type="var">Ty_Num</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">n</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">ENum</span> <span class="id" type="var">n</span>) :- <span class="id" type="var">TNat</span><br/>
| <span class="id" type="var">Ty_Plus</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>1</sub></span> :- <span class="id" type="var">TNat</span> → <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>2</sub></span> :- <span class="id" type="var">TNat</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>) :- <span class="id" type="var">TNat</span>                                    <br/>
| <span class="id" type="var">Ty_Minus</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>1</sub></span> :- <span class="id" type="var">TNat</span> → <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>2</sub></span> :- <span class="id" type="var">TNat</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">EMinus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>) :- <span class="id" type="var">TNat</span>                                    <br/>
| <span class="id" type="var">Ty_Mult</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>1</sub></span> :- <span class="id" type="var">TNat</span> → <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>2</sub></span> :- <span class="id" type="var">TNat</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">EMult</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>) :- <span class="id" type="var">TNat</span>                                    <br/>
| <span class="id" type="var">Ty_True</span> : ∀ <span class="id" type="var">Gamma</span>, <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">ETrue</span> :- <span class="id" type="var">TBool</span><br/>
| <span class="id" type="var">Ty_False</span> : ∀ <span class="id" type="var">Gamma</span>, <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">EFalse</span> :- <span class="id" type="var">TBool</span><br/>
| <span class="id" type="var">Ty_Eq</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>1</sub></span> :- <span class="id" type="var">TNat</span> → <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>2</sub></span> :- <span class="id" type="var">TNat</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>) :- <span class="id" type="var">TBool</span><br/>
| <span class="id" type="var">Ty_Le</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>1</sub></span> :- <span class="id" type="var">TNat</span> → <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>2</sub></span> :- <span class="id" type="var">TNat</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">ELe</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>) :- <span class="id" type="var">TBool</span><br/>
| <span class="id" type="var">Ty_Not</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e</span> :- <span class="id" type="var">TBool</span> →  <span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">ENot</span> <span class="id" type="var">e</span>) :- <span class="id" type="var">TBool</span><br/>
| <span class="id" type="var">Ty_And</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>1</sub></span> :- <span class="id" type="var">TBool</span> → <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e<sub>2</sub></span> :- <span class="id" type="var">TBool</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- (<span class="id" type="var">EAnd</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>) :- <span class="id" type="var">TBool</span><br/>
<br/>
<span class="id" type="keyword">where</span> "Gamma '||-' e ':-' T" := (<span class="id" type="var">has_type</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">e</span> <span class="id" type="var">T</span>).<br/>
</div>

<div class="doc">
Once again, we need a decidable instance for the typing relation of 
    TImp. You can skip to the next exercise if you are not interested in
    specific proof details. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_inductives</span> <span class="id" type="var">Gamma</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="tactic">repeat</span> (<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="var">IH</span> : ∀ <span class="id" type="var">_</span> <span class="id" type="var">_</span>, <span class="id" type="var">_</span> |- <span class="id" type="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H<sub>1</sub></span> := <span class="id" type="tactic">fresh</span> "H<sub>1</sub>" <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pose</span> <span class="id" type="var">proof</span> (<span class="id" type="var">IH</span> <span class="id" type="var">TNat</span> <span class="id" type="var">Gamma</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">H<sub>1</sub></span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">H<sub>2</sub></span> := <span class="id" type="tactic">fresh</span> "H<sub>2</sub>" <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pose</span> <span class="id" type="var">proof</span> (<span class="id" type="var">IH</span> <span class="id" type="var">TBool</span> <span class="id" type="var">Gamma</span>) <span class="id" type="keyword">as</span> <span class="id" type="var">H<sub>2</sub></span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">clear</span> <span class="id" type="var">IH</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">H<sub>1</sub></span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">H<sub>2</sub></span>; <span class="id" type="var">solve_sum</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>
</div>

<div class="doc">
Typing in TImp is decidable: given an expression <span class="inlinecode"><span class="id" type="var">e</span></span>, a context <span class="inlinecode"><span class="id" type="var">Gamma</span></span> 
    and a type <span class="inlinecode"><span class="id" type="var">T</span></span>, we can decide whether <span class="inlinecode"><span class="id" type="var">has_type</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">T</span></span> holds. 
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">dec_has_type</span> (<span class="id" type="var">e</span> : <span class="id" type="var">exp</span>) (<span class="id" type="var">Gamma</span> : <span class="id" type="var">context</span>) (<span class="id" type="var">T</span> : <span class="id" type="var">ty</span>) <br/>
&nbsp;&nbsp;: <span class="id" type="var">Dec</span> (<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e</span> :- <span class="id" type="var">T</span>) :=<br/>
&nbsp;&nbsp;{ <span class="id" type="var">dec</span> := <span class="id" type="var">_</span> }.<br/>
<div class="togglescript" id="proofcontrol2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')"><span class="show"></span></div>
<div class="proofscript" id="proof2" onclick="toggleDisplay('proof2');toggleDisplay('proofcontrol2')">
<span class="id" type="keyword">Proof</span> <span class="id" type="keyword">with</span> <span class="id" type="var">solve_sum</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;I&nbsp;need&nbsp;move:&nbsp;:'(&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">Gamma</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">T</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">e</span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">T</span> <span class="id" type="var">Gamma</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve</span> [<span class="id" type="tactic">destruct</span> <span class="id" type="var">T</span>; <span class="id" type="var">solve_sum</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve</span> [<span class="id" type="tactic">destruct</span> <span class="id" type="var">T</span>; <span class="id" type="var">solve_inductives</span> <span class="id" type="var">Gamma</span>].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;bound_to&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">t</span> <span class="id" type="var">T</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
<a name="lab80"></a><h4 class="section">Exercise: 3 stars (arbitraryExp)</h4>
 Derive <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span> for expressions. Write a conditional property that is
    trivially always true with the precondition that an expression is
    well-typed. Try to check that property. What happens?

<div class="paragraph"> </div>

    (You will need to provide a <span class="inlinecode"><span class="id" type="var">Shrink</span></span> instance for <span class="inlinecode"><span class="id" type="var">Atom</span></span>. The result of
    shrinking an atom can be empty for now) 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab81"></a><h2 class="section">Generator for Typed expressions</h2>

<div class="paragraph"> </div>

 Instead of generating expressions and filtering them using
    has_type, we can be smarter and generate well typed expressions
    for a given context directly. It is common for conditional
    generators to return <span class="inlinecode"><span class="id" type="var">option</span></span>s of the underlying type, allowing
    the possibility of failure if a wrong choice is made. For example,
    if we wanted to generate an expression of type <span class="inlinecode"><span class="id" type="var">TNat</span></span> and chose to
    do that by generating a variable, then we might not be able to
    actually do that (e.g. if the context is empty).

<div class="paragraph"> </div>


<div class="paragraph"> </div>

 To chain two different generetors with type <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode">(<span class="id" type="var">option</span></span> <span class="inlinecode"><span class="id" type="var">A</span>)</span>, we need to 
    execute the first generator, match on its result, and, when it is a <span class="inlinecode"><span class="id" type="var">Some</span></span>, 
    apply the second generator.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">bindGenOpt</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">gma</span> : <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">A</span>)) (<span class="id" type="var">k</span> : <span class="id" type="var">A</span> → <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">B</span>)) <br/>
&nbsp;&nbsp;: <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">B</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">ma</span> &lt;- <span class="id" type="var">gma</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">ma</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">a</span> ⇒ <span class="id" type="var">k</span> <span class="id" type="var">a</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">ret</span> <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
This pattern is common enough that QuickChick provides explicit monadic 
    notation support 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">GOpt</span> <span class="id" type="var">A</span> := <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">A</span>).<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gOptMonad</span> : `{<span class="id" type="var">Monad</span> <span class="id" type="var">GOpt</span>} :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> <span class="id" type="var">A</span> <span class="id" type="var">x</span> := <span class="id" type="var">returnGen</span> (<span class="id" type="var">Some</span> <span class="id" type="var">x</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bind</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">m</span> <span class="id" type="var">k</span> := <span class="id" type="var">bindGenOpt</span> <span class="id" type="var">m</span> <span class="id" type="var">k</span><br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
Which brings us to our first large sized generator for typed expressions.
    We asumme that <span class="inlinecode"><span class="id" type="var">Gamma</span></span> and <span class="inlinecode"><span class="id" type="var">T</span></span> are inputs to the generation process. We also
    use a <span class="inlinecode"><span class="id" type="var">size</span></span> parameter to control the depth of generated expressions.
 
<div class="paragraph"> </div>

 Let's start with a much smaller relation: <span class="inlinecode"><span class="id" type="var">has_type_1</span></span> (which consists of
    just the first constructor of <span class="inlinecode"><span class="id" type="var">has_type</span></span>), that will allow us to demonstrate
    how to build up complex generators for typed expressions from smaller parts. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">has_type_1</span> : <span class="id" type="var">context</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">ty</span> → <span class="id" type="keyword">Prop</span> := <br/>
&nbsp;&nbsp;| <span class="id" type="var">Ty_Var1</span> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">T</span> <span class="id" type="var">Gamma</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T</span> → <span class="id" type="var">has_type_1</span> <span class="id" type="var">Gamma</span> (<span class="id" type="var">EVar</span> <span class="id" type="var">x</span>) <span class="id" type="var">T</span>.<br/>
</div>

<div class="doc">
To generate <span class="inlinecode"><span class="id" type="var">e</span></span> such that for <span class="inlinecode"><span class="id" type="var">has_type_1</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">e</span></span> <span class="inlinecode"><span class="id" type="var">T</span></span> holds, we need to 
    pick one of its constructors to try and satisfy. Here, that means <span class="inlinecode"><span class="id" type="var">Ty_Var1</span></span>. To satisfy, <span class="inlinecode"><span class="id" type="var">Ty_Var1</span></span>, (given <span class="inlinecode"><span class="id" type="var">Gamma</span></span> and <span class="inlinecode"><span class="id" type="var">T</span></span>), we need to generate 
    <span class="inlinecode"><span class="id" type="var">x</span></span> such that <span class="inlinecode"><span class="id" type="var">bound_to</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"><span class="id" type="var">T</span></span>. But we already have such a generator!
    We just need to wrap it in an <span class="inlinecode"><span class="id" type="var">EVar</span></span>.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_typed_evar</span> (<span class="id" type="var">Gamma</span> : <span class="id" type="var">context</span>) (<span class="id" type="var">T</span> : <span class="id" type="var">ty</span>) : <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">exp</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">x</span> &lt;- <span class="id" type="var">gen_typed_atom_from_context</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span>;;<br/>
&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">EVar</span> <span class="id" type="var">x</span>).<br/>
</div>

<div class="doc">
Note: This is the <span class="inlinecode"><span class="id" type="var">ret</span></span> of the <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode">(<span class="id" type="var">option</span></span> <span class="inlinecode">...)</span> monad! 
<div class="paragraph"> </div>

 Now, let's consider a type <span class="inlinecode"><span class="id" type="var">has_type_2</span></span>, extending <span class="inlinecode"><span class="id" type="var">has_type_1</span></span> with all of
    the constructors of <span class="inlinecode"><span class="id" type="var">has_type</span></span> that do not recursively require <span class="inlinecode"><span class="id" type="var">has_type</span></span>
    as a side-condition. These will be the <i>base cases</i> for our generator.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">has_type_2</span> : <span class="id" type="var">context</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">ty</span> → <span class="id" type="keyword">Prop</span> :=<br/>
| <span class="id" type="var">Ty_Var2</span> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">T</span> <span class="id" type="var">Gamma</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T</span> → <span class="id" type="var">has_type_2</span> <span class="id" type="var">Gamma</span> (<span class="id" type="var">EVar</span> <span class="id" type="var">x</span>) <span class="id" type="var">T</span><br/>
| <span class="id" type="var">Ty_Num2</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">n</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">has_type_2</span> <span class="id" type="var">Gamma</span>  (<span class="id" type="var">ENum</span> <span class="id" type="var">n</span>) <span class="id" type="var">TNat</span><br/>
| <span class="id" type="var">Ty_True2</span> : ∀ <span class="id" type="var">Gamma</span>, <span class="id" type="var">has_type_2</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">ETrue</span> <span class="id" type="var">TBool</span><br/>
| <span class="id" type="var">Ty_False2</span> : ∀ <span class="id" type="var">Gamma</span>, <span class="id" type="var">has_type_2</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">EFalse</span> <span class="id" type="var">TBool</span>.<br/>
</div>

<div class="doc">
We can already generate values satisfying <span class="inlinecode"><span class="id" type="var">Ty_Var2</span></span> using <span class="inlinecode"><span class="id" type="var">gen_typed_evar</span></span>. 
    For the rest of the rules, we will need to pattern match on the input 
    <span class="inlinecode"><span class="id" type="var">T</span></span>, since <span class="inlinecode"><span class="id" type="var">Ty_Num</span></span> can only be used if <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">TNat</span></span>, while <span class="inlinecode"><span class="id" type="var">Ty_True</span></span> and 
    <span class="inlinecode"><span class="id" type="var">Ty_False</span></span> can only be satisfied if <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">TBool</span></span>. 
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">base'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span> : <span class="id" type="var">list</span> (<span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">exp</span>)) := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">gen_typed_evar</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span> ::<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">T</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TNat</span>  ⇒ [ <span class="id" type="var">n</span> &lt;- <span class="id" type="var">arbitrary</span>;; <span class="id" type="var">ret</span> (<span class="id" type="var">Some</span> (<span class="id" type="var">ENum</span> <span class="id" type="var">n</span>))]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TBool</span> ⇒ [ <span class="id" type="var">ret</span> <span class="id" type="var">ETrue</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" type="var">ret</span> <span class="id" type="var">EFalse</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We now need to go from a list of (optional) generators to a 
    single generator. We could do that using the <span class="inlinecode"><span class="id" type="var">oneOf</span></span> combinator (that 
    chooses uniformly), or the <span class="inlinecode"><span class="id" type="var">frequency</span></span> combinator (by adding weights).
    Instead, we will use <span class="inlinecode"><span class="id" type="var">backtrack</span></span>:
<pre>
      [ backtrack : list (nat * G (option ?A)) -&gt; G (option ?A) ]
</pre>

<div class="paragraph"> </div>

 Just like <span class="inlinecode"><span class="id" type="var">frequency</span></span>, <span class="inlinecode"><span class="id" type="var">backtrack</span></span> selects one of the generators 
    according to the input weights. Unlike frequency, if the chosen 
    generator fails (i.e. produces <span class="inlinecode"><span class="id" type="var">None</span></span>), it will choose another
    until one succeeds or all options are exhausted. Our base case
    generator could then be: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">base</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2, <span class="id" type="var">gen_typed_evar</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span>) ::<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">T</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TNat</span>  ⇒ [ (2, <span class="id" type="var">n</span> &lt;- <span class="id" type="var">arbitrary</span>;; <span class="id" type="var">ret</span> (<span class="id" type="var">Some</span> (<span class="id" type="var">ENum</span> <span class="id" type="var">n</span>)))]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TBool</span> ⇒ [ (1, <span class="id" type="var">ret</span> <span class="id" type="var">ETrue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (1, <span class="id" type="var">ret</span> <span class="id" type="var">EFalse</span>) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
In the recursive constructors of <span class="inlinecode"><span class="id" type="var">has_type</span></span>, we will also need to pattern
    match on the input <span class="inlinecode"><span class="id" type="var">T</span></span>. If, for example, <span class="inlinecode"><span class="id" type="var">T</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">TNat</span></span>, then we can only
    satisfy typing derivations whose conclusion is of the form 
    <span class="inlinecode"><span class="id" type="var">has_type</span></span> <span class="inlinecode"><span class="id" type="var">Gamma</span></span> <span class="inlinecode"><span class="id" type="var">_</span></span> <span class="inlinecode"><span class="id" type="var">TNat</span></span>, i.e. <span class="inlinecode"><span class="id" type="var">Ty_Plus</span></span>, <span class="inlinecode"><span class="id" type="var">Ty_Minus</span></span> and <span class="inlinecode"><span class="id" type="var">Ty_Mult</span></span>.

<div class="paragraph"> </div>

    Consider <span class="inlinecode"><span class="id" type="var">Ty_Plus</span></span>: we will need to recursively generate expressions <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span>
    and <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span> that have type <span class="inlinecode"><span class="id" type="var">TNat</span></span>, with potentially smaller sizes to ensure
    termination.

<div class="paragraph"> </div>

    We put everything together in the following generator 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">gen_exp_typed_sized</span> (<span class="id" type="var">size</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">Gamma</span> : <span class="id" type="var">context</span>) (<span class="id" type="var">T</span> : <span class="id" type="var">ty</span>) <br/>
&nbsp;&nbsp;: <span class="id" type="var">G</span> (<span class="id" type="var">option</span> <span class="id" type="var">exp</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">base</span> := <span class="id" type="var">base</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">recs</span> <span class="id" type="var">size'</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">T</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TNat</span> ⇒ [ (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>2</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>2</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">EMinus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>2</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">EMult</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TBool</span> ⇒ [ (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>2</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>2</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">ELe</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TBool</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">ENot</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (<span class="id" type="var">size</span>, <span class="id" type="var">e<sub>1</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TBool</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>2</sub></span> &lt;- <span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">size'</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TBool</span> ;; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">EAnd</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)) ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">size</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">backtrack</span> <span class="id" type="var">base</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">size'</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">backtrack</span> (<span class="id" type="var">base</span> ++ <span class="id" type="var">recs</span> <span class="id" type="var">size'</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
When writing such complex generators, it's good to have small tests 
    that ensure that you are generating what you expect. For example, we 
    would expect <span class="inlinecode"><span class="id" type="var">gen_exp_typed_sized</span></span> to always return expressions that are 
    well typed. 

<div class="paragraph"> </div>

    We can use <span class="inlinecode"><span class="id" type="var">forAll</span></span> to encode such a property. 
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_typed_has_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">num_vars</span> := 4 <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">top_level_size</span> := 3 <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_context</span> <span class="id" type="var">num_vars</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">Gamma</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">T</span> ⇒                                   <br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">top_level_size</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">me</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">me</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">e</span> ⇒ (<span class="id" type="var">has_type</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">e</span> <span class="id" type="var">T</span>)?<br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span> <span class="comment">(*&nbsp;this&nbsp;should&nbsp;NEVER&nbsp;fail&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>))).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;gen_typed_has_type.&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab82"></a><h1 class="section">Values and States</h1>

<div class="paragraph"> </div>

<a name="lab83"></a><h2 class="section">Values</h2>

<div class="paragraph"> </div>

 In original Imp, variables range over natural numbers, so states were just
    maps from identifiers to <span class="inlinecode"><span class="id" type="var">nat</span></span>. Since we wanted to extend this to also 
    include booleans, we introduce the type of <span class="inlinecode"><span class="id" type="var">value</span></span>s which includes both. 
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">value</span> := <span class="id" type="var">VNat</span> : <span class="id" type="var">nat</span> → <span class="id" type="var">value</span> | <span class="id" type="var">VBool</span> : <span class="id" type="var">bool</span> → <span class="id" type="var">value</span>.<br/>

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="keyword">Show</span> <span class="id" type="keyword">for</span> <span class="id" type="var">value</span>.<br/>
</div>

<div class="doc">
We can also quickly define a typing relation for values, a Dec instance
    for it and a generator for values of a given type. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">has_type_value</span> : <span class="id" type="var">value</span> → <span class="id" type="var">ty</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">TyVNat</span>  : ∀ <span class="id" type="var">n</span>, <span class="id" type="var">has_type_value</span> (<span class="id" type="var">VNat</span>  <span class="id" type="var">n</span>) <span class="id" type="var">TNat</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">TyVBool</span> : ∀ <span class="id" type="var">b</span>, <span class="id" type="var">has_type_value</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">b</span>) <span class="id" type="var">TBool</span>.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">dec_has_type_value</span> <span class="id" type="var">v</span> <span class="id" type="var">T</span> : <span class="id" type="var">Dec</span> (<span class="id" type="var">has_type_value</span> <span class="id" type="var">v</span> <span class="id" type="var">T</span>).<br/>
<div class="togglescript" id="proofcontrol3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')"><span class="show"></span></div>
<div class="proofscript" id="proof3" onclick="toggleDisplay('proof3');toggleDisplay('proofcontrol3')">
<span class="id" type="keyword">Proof</span>. <span class="id" type="var">constructor</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">v</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">T</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_typed_value</span> (<span class="id" type="var">T</span> : <span class="id" type="var">ty</span>) : <span class="id" type="var">G</span> <span class="id" type="var">value</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">T</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">TNat</span>  ⇒ <span class="id" type="var">n</span> &lt;- <span class="id" type="var">arbitrary</span>;; <span class="id" type="var">ret</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">TBool</span> ⇒ <span class="id" type="var">b</span> &lt;- <span class="id" type="var">arbitrary</span>;; <span class="id" type="var">ret</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">b</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<a name="lab84"></a><h2 class="section">States</h2>

<div class="paragraph"> </div>

 States in TImp are just maps from atoms to values 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">state</span> := @<span class="id" type="var">AtomMap.t</span> <span class="id" type="var">value</span>.<br/>
</div>

<div class="doc">
We introduce an inductive relation that specifies when a state
    is well-typed according to a context: that is, when all of 
    its variables are mapped to values of appropriate types. 

<div class="paragraph"> </div>

    We encode this in an element-by-element style inductive relation: 
    empty states are only well-typed with respect to an empty context, 
    while non-empty states need to map their head atom to a value of the 
    appropriate type and their tails must also be well typed.
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">typed_state</span> : <span class="id" type="var">context</span> → <span class="id" type="var">state</span> → <span class="id" type="keyword">Prop</span> :=<br/>
| <span class="id" type="var">TS_Empty</span> : <span class="id" type="var">typed_state</span> <span class="id" type="var">AtomMap.empty</span> <span class="id" type="var">AtomMap.empty</span><br/>
| <span class="id" type="var">TS_Elem</span>  : ∀ <span class="id" type="var">x</span> <span class="id" type="var">v</span> <span class="id" type="var">T</span> <span class="id" type="var">st</span> <span class="id" type="var">Gamma</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">has_type_value</span> <span class="id" type="var">v</span> <span class="id" type="var">T</span> → <span class="id" type="var">typed_state</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">typed_state</span> ((<span class="id" type="var">x</span>,<span class="id" type="var">T</span>)::<span class="id" type="var">Gamma</span>) ((<span class="id" type="var">x</span>,<span class="id" type="var">v</span>)::<span class="id" type="var">st</span>).<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">dec_typed_state</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span> : <span class="id" type="var">Dec</span> (<span class="id" type="var">typed_state</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span>).<br/>
<div class="togglescript" id="proofcontrol4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')"><span class="show"></span></div>
<div class="proofscript" id="proof4" onclick="toggleDisplay('proof4');toggleDisplay('proofcontrol4')">
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">constructor</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>.<br/>
<span class="id" type="tactic">generalize</span> <span class="id" type="tactic">dependent</span> <span class="id" type="var">Gamma</span>.<br/>
<span class="id" type="tactic">induction</span> <span class="id" type="var">st</span>; <span class="id" type="tactic">intros</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">Gamma</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="tactic">destruct</span> <span class="id" type="var">a</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">a</span> <span class="id" type="var">v</span>]; <span class="id" type="tactic">destruct</span> <span class="id" type="var">p</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">a'</span> <span class="id" type="var">T</span>].<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">Atom.eq_dec</span> <span class="id" type="var">a</span> <span class="id" type="var">a'</span>); <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="tactic">subst</span>; <span class="id" type="var">specialize</span> (<span class="id" type="var">IHst</span> <span class="id" type="var">Gamma</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">IHst</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_has_type_value</span> <span class="id" type="var">v</span> <span class="id" type="var">T</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
To write a generator for well typed states given a context <span class="inlinecode"><span class="id" type="var">Gamma</span></span>, 
    we use the combinator <span class="inlinecode"><span class="id" type="var">sequenceGen</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">list</span></span> <span class="inlinecode">(<span class="id" type="var">G</span></span> <span class="inlinecode"><span class="id" type="var">A</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode">(<span class="id" type="var">list</span></span> <span class="inlinecode"><span class="id" type="var">A</span>)</span>, that 
    receives a list of generators and produces a generator of lists. 
    This is what Haskell's <span class="inlinecode"><span class="id" type="var">sequence</span></span> combinator would do for the monad <span class="inlinecode"><span class="id" type="var">G</span></span>. 

<div class="paragraph"> </div>

    We just need to iterate (<span class="inlinecode"><span class="id" type="var">map</span></span>) through the context, producing
    an arbitrary value of the appropriate type for each pair <span class="inlinecode">(<span class="id" type="var">x</span>,<span class="id" type="var">T</span>)</span>. The 
    <span class="inlinecode"><span class="id" type="var">sequenceGen</span></span> combinator will then chain all those generators in sequence,
    producing a generator for well-typed states 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_typed_state</span> (<span class="id" type="var">Gamma</span> : <span class="id" type="var">context</span>) : <span class="id" type="var">G</span> <span class="id" type="var">state</span> := <br/>
&nbsp;&nbsp;<span class="id" type="var">sequenceGen</span> (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> '(<span class="id" type="var">x</span>, <span class="id" type="var">T</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">v</span> &lt;- <span class="id" type="var">gen_typed_value</span> <span class="id" type="var">T</span>;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> (<span class="id" type="var">x</span>, <span class="id" type="var">v</span>)) <span class="id" type="var">Gamma</span>).<br/>
</div>

<div class="doc">
<a name="lab85"></a><h1 class="section">Evaluation</h1>

<div class="paragraph"> </div>

 Our evaluation function, takes a state and an expression and returns 
    an optional value, assuming that the expression has a type 
    with respect to the state. 
  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">eval</span> (<span class="id" type="var">st</span> : <span class="id" type="var">state</span>) (<span class="id" type="var">e</span> : <span class="id" type="var">exp</span>) : <span class="id" type="var">option</span> <span class="id" type="var">value</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EVar</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">AtomMap.get</span> <span class="id" type="var">st</span> <span class="id" type="var">x</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ENum</span> <span class="id" type="var">n</span> ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>1</sub></span>, <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>2</sub></span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>1</sub></span>), <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>2</sub></span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> (<span class="id" type="var">n<sub>1</sub></span> + <span class="id" type="var">n<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">EMinus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>1</sub></span>, <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>2</sub></span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>1</sub></span>), <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>2</sub></span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> (<span class="id" type="var">n<sub>1</sub></span> - <span class="id" type="var">n<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EMult</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>1</sub></span>, <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>2</sub></span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>1</sub></span>), <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>2</sub></span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> (<span class="id" type="var">n<sub>1</sub></span> * <span class="id" type="var">n<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ETrue</span>       ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">true</span>  )<br/>
&nbsp;&nbsp;| <span class="id" type="var">EFalse</span>      ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">false</span> )<br/>
&nbsp;&nbsp;| <span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>1</sub></span>, <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>2</sub></span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>1</sub></span>), <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>2</sub></span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> (<span class="id" type="var">n<sub>1</sub></span> =? <span class="id" type="var">n<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ELe</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>1</sub></span>, <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>2</sub></span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>1</sub></span>), <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>2</sub></span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> (<span class="id" type="var">n<sub>1</sub></span> &lt;? <span class="id" type="var">n<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ENot</span> <span class="id" type="var">e</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">b</span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">EAnd</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>  ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>1</sub></span>, <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e<sub>2</sub></span> <span class="id" type="keyword">with</span> <br/>
<span class="comment">(*&nbsp;Leo:&nbsp;Stupidest&nbsp;bug&nbsp;possible&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">b</span>), <span class="id" type="var">Some</span> (<span class="id" type="var">VNat</span> <span class="id" type="var">n<sub>2</sub></span>) ⇒ <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> (<span class="id" type="var">negb</span> <span class="id" type="var">b</span>))<br/>
<span class="comment">(*&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Some&nbsp;(VBool&nbsp;b<sub>1</sub>),&nbsp;Some&nbsp;(VBool&nbsp;b<sub>2</sub>)&nbsp;=&gt;&nbsp;Some&nbsp;(VBool&nbsp;(andb&nbsp;b<sub>1</sub>&nbsp;b<sub>2</sub>))&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Type Soundness states that if we have an expression <span class="inlinecode"><span class="id" type="var">e</span></span> of a given type <span class="inlinecode"><span class="id" type="var">T</span></span>, 
    as well as a well-typed state <span class="inlinecode"><span class="id" type="var">st</span></span>, then evaluating <span class="inlinecode"><span class="id" type="var">e</span></span> in <span class="inlinecode"><span class="id" type="var">st</span></span> will
    never fail.
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">isNone</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">m</span> : <span class="id" type="var">option</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="var">Conjecture</span> <span class="id" type="var">expression_soundness</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span> <span class="id" type="var">e</span> <span class="id" type="var">T</span>,  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">typed_state</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span> →  <span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e</span> :- <span class="id" type="var">T</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">isNone</span> (<span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e</span>) = <span class="id" type="var">false</span>.<br/>
</div>

<div class="doc">
To test that property, we construct an appropriate checker 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">expression_soundness_exec</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">num_vars</span> := 4 <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">top_level_size</span> := 3 <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_context</span> <span class="id" type="var">num_vars</span>)  (<span class="id" type="keyword">fun</span> <span class="id" type="var">Gamma</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_typed_state</span> <span class="id" type="var">Gamma</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">T</span> ⇒                                    <br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_exp_typed_sized</span> 3 <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">me</span> ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">me</span> <span class="id" type="keyword">with</span>  <br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">e</span> ⇒ <span class="id" type="var">negb</span> (<span class="id" type="var">isNone</span> (<span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e</span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>)))).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;expression_soundness_exec.&nbsp;*)</span><br/>
</div>

<div class="doc">
<pre>
      ==&gt;
     
       QuickChecking expression_soundness_exec
       [(1,TNat), (2,TNat), (3,TBool), (4,TNat)]
       [(1,VNat 0), (2,VNat 0), (3,VBool true), (4,VNat 0)]
       TBool
       Some EAnd (EAnd (EEq (EVar 4) (EVar 1)) (EEq (ENum 0) (EVar 4))) EFalse
       *** Failed after 8 tests and 0 shrinks. (0 discards)
</pre>
 But where is the bug? That's why we need shrinking... 
<div class="paragraph"> </div>

<a name="lab86"></a><h2 class="section">Shrinking for Expressions</h2>

<div class="paragraph"> </div>

 We not only need to shrink expressions, we need to shrink them so that their
    type is preserved! To accomplish that we need to follow a reverse procedure
    than with the generators: look at a typing derivation and see what parts of
    it we can shrink to appropriate types so that the entire thing is preserved.

<div class="paragraph"> </div>

    For example, to shrink <span class="inlinecode"><span class="id" type="var">EPlus</span></span> <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span>, we could shrink <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> or <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span>
    preserving their <span class="inlinecode"><span class="id" type="var">TNat</span></span> type, or shrink to <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> or <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span> themselves. However,
    for <span class="inlinecode"><span class="id" type="var">EEq</span></span> <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span>, we could to shrink <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> or <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span> again preserving their
    <span class="inlinecode"><span class="id" type="var">TNat</span></span> types, but we couldn't shrink to <span class="inlinecode"><span class="id" type="var">e<sub>1</sub></span></span> or <span class="inlinecode"><span class="id" type="var">e<sub>2</sub></span></span> as their type is wrong.
    
</div>
<div class="code code-tight">
<span class="comment">(*&nbsp;Leo:&nbsp;Not&nbsp;sure&nbsp;how&nbsp;to&nbsp;break&nbsp;up&nbsp;this&nbsp;slide...&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">shrink_exp_typed</span> (<span class="id" type="var">T</span> : <span class="id" type="var">ty</span>) (<span class="id" type="var">e</span> : <span class="id" type="var">exp</span>) : <span class="id" type="var">list</span> <span class="id" type="var">exp</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">EVar</span> <span class="id" type="var">_</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">T</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TNat</span> ⇒ [<span class="id" type="var">ENum</span> 0]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TBool</span> ⇒ [<span class="id" type="var">ETrue</span> ; <span class="id" type="var">EFalse</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ENum</span> <span class="id" type="var">_</span> ⇒ []<br/>
&nbsp;&nbsp;| <span class="id" type="var">ETrue</span> ⇒ []<br/>
&nbsp;&nbsp;| <span class="id" type="var">EFalse</span> ⇒ [<span class="id" type="var">ETrue</span>]<br/>
&nbsp;&nbsp;| <span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>1</sub></span> :: <span class="id" type="var">e<sub>2</sub></span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>1</sub>'</span> ⇒ <span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub>'</span> <span class="id" type="var">e<sub>2</sub></span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>2</sub>'</span> ⇒ <span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub>'</span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e<sub>2</sub></span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">EMinus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>1</sub></span> :: <span class="id" type="var">e<sub>2</sub></span> :: (<span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>1</sub>'</span> ⇒ <span class="id" type="var">EMinus</span> <span class="id" type="var">e<sub>1</sub>'</span> <span class="id" type="var">e<sub>2</sub></span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>2</sub>'</span> ⇒ <span class="id" type="var">EMinus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub>'</span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e<sub>2</sub></span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">EMult</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">e<sub>1</sub></span> :: <span class="id" type="var">e<sub>2</sub></span> :: (<span class="id" type="var">EPlus</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>1</sub>'</span> ⇒ <span class="id" type="var">EMult</span> <span class="id" type="var">e<sub>1</sub>'</span> <span class="id" type="var">e<sub>2</sub></span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>2</sub>'</span> ⇒ <span class="id" type="var">EMult</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub>'</span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e<sub>2</sub></span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ETrue</span> :: <span class="id" type="var">EFalse</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>1</sub>'</span> ⇒ <span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub>'</span> <span class="id" type="var">e<sub>2</sub></span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">TNat</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>2</sub>'</span> ⇒ <span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub>'</span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">TNat</span> <span class="id" type="var">e<sub>2</sub></span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">ELe</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ETrue</span> :: <span class="id" type="var">EFalse</span> :: (<span class="id" type="var">EEq</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>1</sub>'</span> ⇒ <span class="id" type="var">ELe</span> <span class="id" type="var">e<sub>1</sub>'</span> <span class="id" type="var">e<sub>2</sub></span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">TNat</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>2</sub>'</span> ⇒ <span class="id" type="var">ELe</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub>'</span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">TNat</span> <span class="id" type="var">e<sub>2</sub></span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">ENot</span> <span class="id" type="var">e</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ETrue</span> :: <span class="id" type="var">EFalse</span> :: <span class="id" type="var">e</span> :: (<span class="id" type="var">List.map</span> <span class="id" type="var">ENot</span> (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e</span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">EAnd</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub></span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ETrue</span> :: <span class="id" type="var">EFalse</span> :: <span class="id" type="var">e<sub>1</sub></span> :: <span class="id" type="var">e<sub>2</sub></span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:: (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>1</sub>'</span> ⇒ <span class="id" type="var">EAnd</span> <span class="id" type="var">e<sub>1</sub>'</span> <span class="id" type="var">e<sub>2</sub></span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">TBool</span> <span class="id" type="var">e<sub>1</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">List.map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e<sub>2</sub>'</span> ⇒ <span class="id" type="var">EAnd</span> <span class="id" type="var">e<sub>1</sub></span> <span class="id" type="var">e<sub>2</sub>'</span>) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">TBool</span> <span class="id" type="var">e<sub>2</sub></span>))<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Similarly with generators, we can have a sanity check for our shrinking:
    Given a random expression of a given type, all of the results of <span class="inlinecode"><span class="id" type="var">shrink</span></span>
    should have the same type. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">shrink_typed_has_type</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">num_vars</span> := 4 <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">top_level_size</span> := 3 <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_context</span> <span class="id" type="var">num_vars</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">Gamma</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">T</span> ⇒                                   <br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_exp_typed_sized</span> <span class="id" type="var">top_level_size</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">me</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">me</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">e</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">List.forallb</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">e'</span> ⇒ (<span class="id" type="var">has_type</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">e'</span> <span class="id" type="var">T</span>)?) (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span> <span class="id" type="var">e</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span> <span class="comment">(*&nbsp;this&nbsp;should&nbsp;NEVER&nbsp;fail&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>))).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;shrink_typed_has_type.&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab87"></a><h2 class="section">Back to Soundness</h2>

<div class="paragraph"> </div>

 To lift the shrinker to optional expressions, QuickChick provides a <span class="inlinecode"><span class="id" type="var">lift</span></span>
    function. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">lift_shrink</span> {<span class="id" type="var">A</span>} (<span class="id" type="var">shr</span> : <span class="id" type="var">A</span> → <span class="id" type="var">list</span> <span class="id" type="var">A</span>) (<span class="id" type="var">m</span> : <span class="id" type="var">option</span> <span class="id" type="var">A</span>) <br/>
&nbsp;&nbsp;: <span class="id" type="var">list</span> (<span class="id" type="var">option</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">m</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">x</span> ⇒ <span class="id" type="var">List.map</span> <span class="id" type="var">Some</span> (<span class="id" type="var">shr</span> <span class="id" type="var">x</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ []<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Armed with shrinking we can pinpoint the bug in the <span class="inlinecode"><span class="id" type="var">EAnd</span></span> branch 
    and remove the obvious bug in evaluating<span class="inlinecode"><span class="id" type="var">EAnd</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">expression_soundness_exec'</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">num_vars</span> := 4 <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">top_level_size</span> := 3 <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_context</span> <span class="id" type="var">num_vars</span>)  (<span class="id" type="keyword">fun</span> <span class="id" type="var">Gamma</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_typed_state</span> <span class="id" type="var">Gamma</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">st</span> ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">T</span> ⇒                                    <br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrink</span> (<span class="id" type="var">gen_exp_typed_sized</span> 3 <span class="id" type="var">Gamma</span> <span class="id" type="var">T</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">lift_shrink</span> (<span class="id" type="var">shrink_exp_typed</span> <span class="id" type="var">T</span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">me</span> ⇒  <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">me</span> <span class="id" type="keyword">with</span>  <br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">e</span> ⇒ <span class="id" type="var">negb</span> (<span class="id" type="var">isNone</span> (<span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e</span>))<br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>)))).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;expression_soundness_exec'.&nbsp;*)</span><br/>
</div>

<div class="doc">
<pre>
     ==&gt;
        QuickChecking expression_soundness_exec'
        [(1,TNat), (2,TNat), (3,TNat), (4,TBool)]
        [(1,VNat 0), (2,VNat 0), (3,VNat 0), (4,VBool false)]
        TBool
        Some EAnd ETrue ETrue
        *** Failed after 8 tests and 1 shrinks. (0 discards)
</pre>

<div class="paragraph"> </div>

<a name="lab88"></a><h1 class="section">Well-typed programs</h1>

<div class="paragraph"> </div>

 We now introduce TImp commands, exactly like the ones in Imp 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">com</span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">CSkip</span>  : <span class="id" type="var">com</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">CAss</span>   : <span class="id" type="var">Atom.t</span> → <span class="id" type="var">exp</span> → <span class="id" type="var">com</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">CSeq</span>   : <span class="id" type="var">com</span>    → <span class="id" type="var">com</span> → <span class="id" type="var">com</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">CIf</span>    : <span class="id" type="var">exp</span>    → <span class="id" type="var">com</span> → <span class="id" type="var">com</span> → <span class="id" type="var">com</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">CWhile</span> : <span class="id" type="var">exp</span>    → <span class="id" type="var">com</span> → <span class="id" type="var">com</span>.<br/>

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="keyword">Show</span> <span class="id" type="keyword">for</span> <span class="id" type="var">com</span>.<br/>
</div>

<div class="doc">
As usual, we can use a few <span class="inlinecode"><span class="id" type="keyword">Notation</span></span> declarations to make things
    more readable.  To avoid conflicts with Coq's built-in notations,
    we keep this light &mdash; in particular, we don't introduce any
    notations for <span class="inlinecode"><span class="id" type="var">exps</span></span> and <span class="inlinecode"><span class="id" type="var">exps</span></span> to avoid confusion with the
    numeric and boolean operators we've already defined. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "'SKIP'" :=<br/>
&nbsp;&nbsp;<span class="id" type="var">CSkip</span>.<br/>
<span class="id" type="keyword">Notation</span> "x '::=' a" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">CAss</span> <span class="id" type="var">x</span> <span class="id" type="var">a</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 60).<br/>
<span class="id" type="keyword">Notation</span> "c<sub>1</sub> ;;; c<sub>2</sub>" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">CSeq</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">c<sub>2</sub></span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 80, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> "'WHILE' b 'DO' c 'END'" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">CWhile</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 80, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
<span class="id" type="keyword">Notation</span> "'IFB' c<sub>1</sub> 'THEN' c<sub>2</sub> 'ELSE' c<sub>3</sub> 'FI'" :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">CIf</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">c<sub>2</sub></span> <span class="id" type="var">c<sub>3</sub></span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 80, <span class="id" type="var">right</span> <span class="id" type="var">associativity</span>).<br/>
</div>

<div class="doc">
<a name="lab89"></a><h2 class="section">Well-typed commands</h2>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">well_typed_com</span> : <span class="id" type="var">context</span> → <span class="id" type="var">com</span> → <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">TSkip</span> : ∀ <span class="id" type="var">Gamma</span>, <span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">CSkip</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">TAss</span>  : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">e</span> <span class="id" type="var">T</span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">e</span> :- <span class="id" type="var">T</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> (<span class="id" type="var">CAss</span> <span class="id" type="var">x</span> <span class="id" type="var">e</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">TSeq</span>  : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">c<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c<sub>1</sub></span> → <span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c<sub>2</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> (<span class="id" type="var">CSeq</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">c<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">TIf</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">b</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">c<sub>2</sub></span>, <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">b</span> :- <span class="id" type="var">TBool</span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c<sub>1</sub></span> → <span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c<sub>2</sub></span> →<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> (<span class="id" type="var">CIf</span> <span class="id" type="var">b</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">c<sub>2</sub></span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">TWhile</span> : ∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Gamma</span> ||- <span class="id" type="var">b</span> :- <span class="id" type="var">TBool</span> → <span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c</span> → <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> (<span class="id" type="var">CWhile</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span>).<br/>
</div>

<div class="doc">
Decidable instance for well-typed. 
<div class="paragraph"> </div>

 A couple of lemmas to help the decidability proof. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">bind_deterministic</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> (<span class="id" type="var">T<sub>1</sub></span> <span class="id" type="var">T<sub>2</sub></span> : <span class="id" type="var">ty</span>) :<br/>
&nbsp;&nbsp;<span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T<sub>1</sub></span> → <span class="id" type="var">bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">x</span> <span class="id" type="var">T<sub>2</sub></span> → <br/>
&nbsp;&nbsp;<span class="id" type="var">T<sub>1</sub></span> = <span class="id" type="var">T<sub>2</sub></span>.<br/>
<div class="togglescript" id="proofcontrol5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')"><span class="show"></span></div>
<div class="proofscript" id="proof5" onclick="toggleDisplay('proof5');toggleDisplay('proofcontrol5')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">T<sub>1</sub></span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">T<sub>2</sub></span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H<sub>1</sub></span> <span class="id" type="var">H<sub>2</sub></span>; <span class="id" type="tactic">eauto</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>1</sub></span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>2</sub></span>; <span class="id" type="tactic">congruence</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">has_type_deterministic</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">e</span> (<span class="id" type="var">T<sub>1</sub></span> <span class="id" type="var">T<sub>2</sub></span> : <span class="id" type="var">ty</span>) : <br/>
&nbsp;&nbsp;<span class="id" type="var">has_type</span> <span class="id" type="var">e</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T<sub>1</sub></span> → <span class="id" type="var">has_type</span> <span class="id" type="var">e</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">T<sub>2</sub></span> → <br/>
&nbsp;&nbsp;<span class="id" type="var">T<sub>1</sub></span> = <span class="id" type="var">T<sub>2</sub></span>.<br/>
<div class="togglescript" id="proofcontrol6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')"><span class="show"></span></div>
<div class="proofscript" id="proof6" onclick="toggleDisplay('proof6');toggleDisplay('proofcontrol6')">
<span class="id" type="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">T<sub>1</sub></span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">T<sub>2</sub></span>; <span class="id" type="tactic">intros</span> <span class="id" type="var">H<sub>1</sub></span> <span class="id" type="var">H<sub>2</sub></span>; <span class="id" type="tactic">eauto</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>1</sub></span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>2</sub></span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">eauto</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">congruence</span>;<br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">H<sub>7</sub></span>; <span class="id" type="tactic">subst</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">eapply</span> <span class="id" type="var">bind_deterministic</span>; <span class="id" type="tactic">eauto</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<br/>
</div>

<div class="doc">
More tactic magic needed for the decidability instance for 
    <span class="inlinecode"><span class="id" type="var">well_typed_com</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_det</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| [ <span class="id" type="var">H<sub>1</sub></span> : <span class="id" type="var">bound_to</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">T<sub>1</sub></span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">H<sub>2</sub></span> : <span class="id" type="var">bound_to</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">T<sub>2</sub></span> |- <span class="id" type="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">T<sub>1</sub></span> = <span class="id" type="var">T<sub>2</sub></span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">eapply</span> <span class="id" type="var">bind_deterministic</span>; <span class="id" type="tactic">eauto</span>)<br/>
&nbsp;&nbsp;| [ <span class="id" type="var">H<sub>1</sub></span> : <span class="id" type="var">has_type</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">T<sub>1</sub></span> ,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">H<sub>2</sub></span> : <span class="id" type="var">has_type</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> ?<span class="id" type="var">T<sub>2</sub></span> |- <span class="id" type="var">_</span> ] ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">assert</span> (<span class="id" type="var">T<sub>1</sub></span> = <span class="id" type="var">T<sub>2</sub></span>) <span class="id" type="tactic">by</span> (<span class="id" type="tactic">eapply</span> <span class="id" type="var">bind_deterministic</span>; <span class="id" type="tactic">eauto</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We also provide a (brute-force) decidability procedure for well typed 
    programs. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">dec_well_typed_com</span> (<span class="id" type="var">Gamma</span> : <span class="id" type="var">context</span>) (<span class="id" type="var">c</span> : <span class="id" type="var">com</span>) <br/>
&nbsp;&nbsp;: <span class="id" type="var">Dec</span> (<span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c</span>) := {}.<br/>
<div class="togglescript" id="proofcontrol7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')"><span class="show"></span></div>
<div class="proofscript" id="proof7" onclick="toggleDisplay('proof7');toggleDisplay('proofcontrol7')">
<span class="id" type="keyword">Proof</span> <span class="id" type="keyword">with</span> <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">induction</span> <span class="id" type="var">c</span>; <span class="id" type="var">solve_sum</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">t</span> <span class="id" type="var">TNat</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_has_type</span> <span class="id" type="var">e</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TNat</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_bound_to</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">t</span> <span class="id" type="var">TBool</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_has_type</span> <span class="id" type="var">e</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TBool</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>; <span class="id" type="var">solve_sum</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve_det</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">right</span>; <span class="id" type="tactic">intro</span> <span class="id" type="var">Contra</span>; <span class="id" type="tactic">inversion</span> <span class="id" type="var">Contra</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">clear</span> <span class="id" type="var">Contra</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve_det</span>; <span class="id" type="tactic">try</span> <span class="id" type="tactic">congruence</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> <span class="id" type="var">T</span>; <span class="id" type="tactic">eauto</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">IHc1</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">IHc2</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">eauto</span>; <span class="id" type="var">solve_sum</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">IHc1</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">IHc2</span>; <span class="id" type="tactic">subst</span>; <span class="id" type="tactic">eauto</span>; <span class="id" type="var">solve_sum</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_has_type</span> <span class="id" type="var">e</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TBool</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>; <span class="id" type="var">solve_sum</span>.<br/>
&nbsp;&nbsp;- <span class="id" type="tactic">destruct</span> <span class="id" type="var">IHc</span>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">destruct</span> (<span class="id" type="var">dec_has_type</span> <span class="id" type="var">e</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">TBool</span>); <span class="id" type="tactic">destruct</span> <span class="id" type="var">dec</span>; <span class="id" type="var">solve_sum</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
</div>

<div class="doc">
<a name="lab90"></a><h4 class="section">Exercise: 4 stars (arbitrary_well_typed_com)</h4>
 Write a generator and a shrinker for well_typed programs
    given some context <span class="inlinecode"><span class="id" type="var">Gamma</span></span>. 

<div class="paragraph"> </div>

    Write sanity checks to check your work. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
To complete the tour of TImp, here is a (buggy?) evaluation function for
    commands given a state. To ensure termination, we include an additional fuel
    parameter: if that runs out we return <span class="inlinecode"><span class="id" type="var">OutOfGas</span></span>, signifying that we're not
    sure if evaluation would have succeeded or failed later.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">result</span> := <br/>
| <span class="id" type="var">Success</span> : <span class="id" type="var">state</span> → <span class="id" type="var">result</span><br/>
| <span class="id" type="var">Fail</span> : <span class="id" type="var">result</span> <br/>
| <span class="id" type="var">OutOfGas</span> : <span class="id" type="var">result</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">ceval</span> (<span class="id" type="var">fuel</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">st</span> : <span class="id" type="var">state</span>) (<span class="id" type="var">c</span> : <span class="id" type="var">com</span>) : <span class="id" type="var">result</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">fuel</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">OutOfGas</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">fuel'</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">SKIP</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Success</span> <span class="id" type="var">st</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">x</span> ::= <span class="id" type="var">e</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">v</span> ⇒ <span class="id" type="var">Success</span> (<span class="id" type="var">AtomMap.set</span> <span class="id" type="var">st</span> <span class="id" type="var">x</span> <span class="id" type="var">v</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">Fail</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">c<sub>1</sub></span> ;;; <span class="id" type="var">c<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">ceval</span> <span class="id" type="var">fuel'</span> <span class="id" type="var">st</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Success</span> <span class="id" type="var">st'</span> ⇒  <span class="id" type="var">ceval</span> <span class="id" type="var">fuel'</span> <span class="id" type="var">st'</span> <span class="id" type="var">c<sub>2</sub></span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">Fail</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">IFB</span> <span class="id" type="var">b</span> <span class="id" type="var">THEN</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="var">ELSE</span> <span class="id" type="var">c<sub>2</sub></span> <span class="id" type="var">FI</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">b</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ceval</span> <span class="id" type="var">fuel'</span> <span class="id" type="var">st</span> (<span class="id" type="keyword">if</span> <span class="id" type="var">b</span> <span class="id" type="keyword">then</span> <span class="id" type="var">c<sub>1</sub></span> <span class="id" type="keyword">else</span> <span class="id" type="var">c<sub>2</sub></span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">Fail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">WHILE</span> <span class="id" type="var">b</span> <span class="id" type="var">DO</span> <span class="id" type="var">c</span> <span class="id" type="var">END</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">eval</span> <span class="id" type="var">st</span> <span class="id" type="var">b</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">VBool</span> <span class="id" type="var">b'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">b'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">ceval</span> <span class="id" type="var">fuel'</span> <span class="id" type="var">st</span> (<span class="id" type="var">c</span> ;;; <span class="id" type="var">WHILE</span> <span class="id" type="var">b</span> <span class="id" type="var">DO</span> <span class="id" type="var">c</span> <span class="id" type="var">END</span>) <span class="id" type="keyword">else</span> <span class="id" type="var">Success</span> <span class="id" type="var">st</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">Fail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">isFail</span> <span class="id" type="var">r</span> := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">r</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Fail</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Our type soundness property is that well_typed commands never fail. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Conjecture</span> <span class="id" type="var">well_typed_state_never_stuck</span> : <br/>
&nbsp;&nbsp;∀ <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span>, <span class="id" type="var">typed_state</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">st</span> →<br/>
&nbsp;&nbsp;∀ <span class="id" type="var">c</span>, <span class="id" type="var">well_typed_com</span> <span class="id" type="var">Gamma</span> <span class="id" type="var">c</span> →<br/>
&nbsp;&nbsp;∀ <span class="id" type="var">fuel</span>, <span class="id" type="var">isFail</span> (<span class="id" type="var">ceval</span> <span class="id" type="var">fuel</span> <span class="id" type="var">st</span> <span class="id" type="var">c</span>) = <span class="id" type="var">false</span>.<br/>
</div>

<div class="doc">
<a name="lab91"></a><h4 class="section">Exercise: 4 stars (well_typed_state_never_stuck)</h4>
 Write a checker for the above property, find any bugs and fix them. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>